// This file is auto-generated. Do not edit!

#include "precomp.hpp"
#include "opencl_kernels.hpp"

namespace cv
{
namespace ocl
{
namespace imgproc
{

const struct ProgramEntry accumulate={"accumulate",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void accumulate(__global const uchar * srcptr, int src_step, int src_offset,\n"
"#ifdef ACCUMULATE_PRODUCT\n"
"__global const uchar * src2ptr, int src2_step, int src2_offset,\n"
"#endif\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols\n"
"#ifdef ACCUMULATE_WEIGHTED\n"
", dstT alpha\n"
"#endif\n"
"#ifdef HAVE_MASK\n"
", __global const uchar * mask, int mask_step, int mask_offset\n"
"#endif\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src_index = mad24(y, src_step, src_offset + x * cn * (int)sizeof(srcT));\n"
"#ifdef HAVE_MASK\n"
"int mask_index = mad24(y, mask_step, mask_offset + x);\n"
"mask += mask_index;\n"
"#endif\n"
"int dst_index = mad24(y, dst_step, dst_offset + x * cn * (int)sizeof(dstT));\n"
"__global const srcT * src = (__global const srcT *)(srcptr + src_index);\n"
"#ifdef ACCUMULATE_PRODUCT\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * cn * (int)sizeof(srcT));\n"
"__global const srcT * src2 = (__global const srcT *)(src2ptr + src2_index);\n"
"#endif\n"
"__global dstT * dst = (__global dstT *)(dstptr + dst_index);\n"
"#pragma unroll\n"
"for (int c = 0; c < cn; ++c)\n"
"#ifdef HAVE_MASK\n"
"if (mask[0])\n"
"#endif\n"
"#ifdef ACCUMULATE\n"
"dst[c] += src[c];\n"
"#elif defined ACCUMULATE_SQUARE\n"
"dst[c] += src[c] * src[c];\n"
"#elif defined ACCUMULATE_PRODUCT\n"
"dst[c] += src[c] * src2[c];\n"
"#elif defined ACCUMULATE_WEIGHTED\n"
"dst[c] = (1 - alpha) * dst[c] + src[c] * alpha;\n"
"#else\n"
"#error \"Unknown accumulation type\"\n"
"#endif\n"
"}\n"
"}\n"
, "eec8133ba9e4804357b3fb8de107ad29"};
ProgramSource accumulate_oclsrc(accumulate.programStr);
const struct ProgramEntry bilateral={"bilateral",
"__kernel void bilateral(__global const uchar * src, int src_step, int src_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant float * color_weight, __constant float * space_weight, __constant int * space_ofs)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < dst_rows && x < dst_cols)\n"
"{\n"
"int src_index = mad24(y + radius, src_step, x + radius + src_offset);\n"
"int dst_index = mad24(y, dst_step, x + dst_offset);\n"
"float sum = 0.f, wsum = 0.f;\n"
"int val0 = convert_int(src[src_index]);\n"
"#pragma unroll\n"
"for (int k = 0; k < maxk; k++ )\n"
"{\n"
"int val = convert_int(src[src_index + space_ofs[k]]);\n"
"float w = space_weight[k] * color_weight[abs(val - val0)];\n"
"sum += (float)(val) * w;\n"
"wsum += w;\n"
"}\n"
"dst[dst_index] = convert_uchar_rtz(sum / wsum + 0.5f);\n"
"}\n"
"}\n"
, "575f9170e0b242f150da3b29b394e5bf"};
ProgramSource bilateral_oclsrc(bilateral.programStr);
const struct ProgramEntry blend_linear={"blend_linear",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"__kernel void blendLinear(__global const uchar * src1ptr, int src1_step, int src1_offset,\n"
"__global const uchar * src2ptr, int src2_step, int src2_offset,\n"
"__global const uchar * weight1, int weight1_step, int weight1_offset,\n"
"__global const uchar * weight2, int weight2_step, int weight2_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, src1_offset + x * cn * (int)sizeof(T));\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * cn * (int)sizeof(T));\n"
"int weight1_index = mad24(y, weight1_step, weight1_offset + x * (int)sizeof(float));\n"
"int weight2_index = mad24(y, weight2_step, weight2_offset + x * (int)sizeof(float));\n"
"int dst_index = mad24(y, dst_step, dst_offset + x * cn * (int)sizeof(T));\n"
"float w1 = *(__global const float *)(weight1 + weight1_index),\n"
"w2 = *(__global const float *)(weight2 + weight2_index);\n"
"float den = w1 + w2 + 1e-5f;\n"
"__global const T * src1 = (__global const T *)(src1ptr + src1_index);\n"
"__global const T * src2 = (__global const T *)(src2ptr + src2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#pragma unroll\n"
"for (int i = 0; i < cn; ++i)\n"
"{\n"
"float num = w1 * convert_float(src1[i]) + w2 * convert_float(src2[i]);\n"
"dst[i] = convertToT(num / den);\n"
"}\n"
"}\n"
"}\n"
, "76072b51c3ede4951ee0200aa33297dc"};
ProgramSource blend_linear_oclsrc(blend_linear.programStr);
const struct ProgramEntry boxFilter={"boxFilter",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"x = max(min(x, maxX - 1), minX); \\\n"
"y = max(min(y, maxY - 1), minY); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x -= ((x - maxX + 1) / maxX) * maxX; \\\n"
"if (x >= maxX) \\\n"
"x %= maxX; \\\n"
"if (y < minY) \\\n"
"y -= ((y - maxY + 1) / maxY) * maxY; \\\n"
"if (y >= maxY) \\\n"
"y %= maxY; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n"
"{ \\\n"
"if (maxX - minX == 1) \\\n"
"x = minX; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x = minX - (x - minX) - 1 + delta; \\\n"
"else \\\n"
"x = maxX - 1 - (x - maxX) - delta; \\\n"
"} \\\n"
"while (x >= maxX || x < minX); \\\n"
"\\\n"
"if (maxY - minY == 1) \\\n"
"y = minY; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (y < minY) \\\n"
"y = minY - (y - minY) - 1 + delta; \\\n"
"else \\\n"
"y = maxY - 1 - (y - maxY) - delta; \\\n"
"} \\\n"
"while (y >= maxY || y < minY); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n"
"#elif defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define noconvert\n"
"#ifdef SQR\n"
"#define PROCESS_ELEM(value) (value * value)\n"
"#else\n"
"#define PROCESS_ELEM(value) value\n"
"#endif\n"
"struct RectCoords\n"
"{\n"
"int x1, y1, x2, y2;\n"
"};\n"
"inline WT readSrcPixel(int2 pos, __global const uchar * srcptr, int src_step, const struct RectCoords srcCoords)\n"
"{\n"
"#ifdef BORDER_ISOLATED\n"
"if (pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#else\n"
"if (pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#endif\n"
"{\n"
"int src_index = mad24(pos.y, src_step, pos.x * (int)sizeof(ST));\n"
"WT value = convertToWT(*(__global const ST *)(srcptr + src_index));\n"
"return PROCESS_ELEM(value);\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"return (WT)(0);\n"
"#else\n"
"int selected_col = pos.x, selected_row = pos.y;\n"
"EXTRAPOLATE(selected_col, selected_row,\n"
"#ifdef BORDER_ISOLATED\n"
"srcCoords.x1, srcCoords.y1,\n"
"#else\n"
"0, 0,\n"
"#endif\n"
"srcCoords.x2, srcCoords.y2);\n"
"int src_index = mad24(selected_row, src_step, selected_col * (int)sizeof(ST));\n"
"WT value = convertToWT(*(__global const ST *)(srcptr + src_index));\n"
"return PROCESS_ELEM(value);\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void boxFilter(__global const uchar * srcptr, int src_step, int srcOffsetX, int srcOffsetY, int srcEndX, int srcEndY,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols\n"
"#ifdef NORMALIZE\n"
", float alpha\n"
"#endif\n"
")\n"
"{\n"
"const struct RectCoords srcCoords = { srcOffsetX, srcOffsetY, srcEndX, srcEndY };\n"
"int x = get_local_id(0) + (LOCAL_SIZE_X - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\n"
"int y = get_global_id(1) * BLOCK_SIZE_Y;\n"
"int local_id = get_local_id(0);\n"
"WT data[KERNEL_SIZE_Y];\n"
"__local WT sumOfCols[LOCAL_SIZE_X];\n"
"int2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\n"
"#pragma unroll\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++, srcPos.y++)\n"
"data[sy] = readSrcPixel(srcPos, srcptr, src_step, srcCoords);\n"
"WT tmp_sum = (WT)(0);\n"
"#pragma unroll\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n"
"tmp_sum += data[sy];\n"
"sumOfCols[local_id] = tmp_sum;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(DT) + dst_offset);\n"
"__global DT * dst = (__global DT *)(dstptr + dst_index);\n"
"int sy_index = 0;\n"
"for (int i = 0, stepY = min(rows - y, BLOCK_SIZE_Y); i < stepY; ++i)\n"
"{\n"
"if (local_id >= ANCHOR_X && local_id < LOCAL_SIZE_X - (KERNEL_SIZE_X - 1 - ANCHOR_X) &&\n"
"x >= 0 && x < cols)\n"
"{\n"
"WT total_sum = (WT)(0);\n"
"#pragma unroll\n"
"for (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n"
"total_sum += sumOfCols[local_id + sx - ANCHOR_X];\n"
"#ifdef NORMALIZE\n"
"dst[0] = convertToDT((WT)(alpha) * total_sum);\n"
"#else\n"
"dst[0] = convertToDT(total_sum);\n"
"#endif\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"tmp_sum = sumOfCols[local_id];\n"
"tmp_sum -= data[sy_index];\n"
"data[sy_index] = readSrcPixel(srcPos, srcptr, src_step, srcCoords);\n"
"srcPos.y++;\n"
"tmp_sum += data[sy_index];\n"
"sumOfCols[local_id] = tmp_sum;\n"
"sy_index = sy_index + 1 < KERNEL_SIZE_Y ? sy_index + 1 : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"dst = (__global DT *)((__global uchar *)dst + dst_step);\n"
"}\n"
"}\n"
, "aa20276fbacb68ff554bfedcad830a69"};
ProgramSource boxFilter_oclsrc(boxFilter.programStr);
const struct ProgramEntry calc_back_project={"calc_back_project",
"#define OUT_OF_RANGE -1\n"
"#if histdims == 1\n"
"__kernel void calcLUT(__global const uchar * histptr, int hist_step, int hist_offset, int hist_bins,\n"
"__global int * lut, float scale, __constant float * ranges)\n"
"{\n"
"int x = get_global_id(0);\n"
"float value = convert_float(x);\n"
"if (value > ranges[1] || value < ranges[0])\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"float lb = ranges[0], ub = ranges[1], gap = (ub - lb) / hist_bins;\n"
"value -= lb;\n"
"int bin = convert_int_sat_rtn(value / gap);\n"
"if (bin >= hist_bins)\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"int hist_index = mad24(hist_step, bin, hist_offset);\n"
"__global const float * hist = (__global const float *)(histptr + hist_index);\n"
"lut[x] = (int)convert_uchar_sat_rte(hist[0] * scale);\n"
"}\n"
"}\n"
"}\n"
"__kernel void LUT(__global const uchar * src, int src_step, int src_offset,\n"
"__constant int * lut,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src_index = mad24(y, src_step, src_offset + x * scn);\n"
"int dst_index = mad24(y, dst_step, dst_offset + x);\n"
"int value = lut[src[src_index]];\n"
"dst[dst_index] = value == OUT_OF_RANGE ? 0 : convert_uchar(value);\n"
"}\n"
"}\n"
"#elif histdims == 2\n"
"__kernel void calcLUT(int hist_bins, __global int * lut, int lut_offset,\n"
"__constant float * ranges, int roffset)\n"
"{\n"
"int x = get_global_id(0);\n"
"float value = convert_float(x);\n"
"ranges += roffset;\n"
"lut += lut_offset;\n"
"if (value > ranges[1] || value < ranges[0])\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"float lb = ranges[0], ub = ranges[1], gap = (ub - lb) / hist_bins;\n"
"value -= lb;\n"
"int bin = convert_int_sat_rtn(value / gap);\n"
"lut[x] = bin >= hist_bins ? OUT_OF_RANGE : bin;\n"
"}\n"
"}\n"
"__kernel void LUT(__global const uchar * src1, int src1_step, int src1_offset,\n"
"__global const uchar * src2, int src2_step, int src2_offset,\n"
"__global const uchar * histptr, int hist_step, int hist_offset,\n"
"__constant int * lut, float scale,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, src1_offset + x * scn1);\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * scn2);\n"
"int dst_index = mad24(y, dst_step, dst_offset + x);\n"
"int bin1 = lut[src1[src1_index]];\n"
"int bin2 = lut[src2[src2_index] + 256];\n"
"dst[dst_index] = bin1 == OUT_OF_RANGE || bin2 == OUT_OF_RANGE ? 0 :\n"
"convert_uchar_sat_rte(*(__global const float *)(histptr +\n"
"mad24(hist_step, bin1, hist_offset + bin2 * (int)sizeof(float))) * scale);\n"
"}\n"
"}\n"
"#else\n"
"#error \"(nimages <= 2) should be true\"\n"
"#endif\n"
, "a69c4bdfeda12ce56ca8de84e890b3d3"};
ProgramSource calc_back_project_oclsrc(calc_back_project.programStr);
const struct ProgramEntry canny={"canny",
"__kernel void __attribute__((reqd_work_group_size(16, 16, 1)))\n"
"calcSobelRowPass\n"
"(__global const uchar * src, int src_step, int src_offset, int rows, int cols,\n"
"__global uchar * dx_buf, int dx_buf_step, int dx_buf_offset,\n"
"__global uchar * dy_buf, int dy_buf_step, int dy_buf_offset)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local int smem[16][18];\n"
"smem[lidy][lidx + 1] = src[mad24(src_step, min(gidy, rows - 1), gidx + src_offset)];\n"
"if (lidx == 0)\n"
"{\n"
"smem[lidy][0]  = src[mad24(src_step, min(gidy, rows - 1), max(gidx - 1,  0)        + src_offset)];\n"
"smem[lidy][17] = src[mad24(src_step, min(gidy, rows - 1), min(gidx + 16, cols - 1) + src_offset)];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidy < rows && gidx < cols)\n"
"{\n"
"*(__global short *)(dx_buf + mad24(gidy, dx_buf_step, gidx * (int)sizeof(short) + dx_buf_offset)) =\n"
"smem[lidy][lidx + 2] - smem[lidy][lidx];\n"
"*(__global short *)(dy_buf + mad24(gidy, dy_buf_step, gidx * (int)sizeof(short) + dy_buf_offset)) =\n"
"smem[lidy][lidx] + 2 * smem[lidy][lidx + 1] + smem[lidy][lidx + 2];\n"
"}\n"
"}\n"
"inline int calc(short x, short y)\n"
"{\n"
"#ifdef L2GRAD\n"
"return x * x + y * y;\n"
"#else\n"
"return (x >= 0 ? x : -x) + (y >= 0 ? y : -y);\n"
"#endif\n"
"}\n"
"__kernel void calcMagnitude(__global const uchar * dxptr, int dx_step, int dx_offset,\n"
"__global const uchar * dyptr, int dy_step, int dy_offset,\n"
"__global uchar * magptr, int mag_step, int mag_offset, int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int dx_index = mad24(dx_step, y, x * (int)sizeof(short) + dx_offset);\n"
"int dy_index = mad24(dy_step, y, x * (int)sizeof(short) + dy_offset);\n"
"int mag_index = mad24(mag_step, y + 1, (x + 1) * (int)sizeof(int) + mag_offset);\n"
"__global const short * dx = (__global const short *)(dxptr + dx_index);\n"
"__global const short * dy = (__global const short *)(dyptr + dy_index);\n"
"__global int * mag = (__global int *)(magptr + mag_index);\n"
"mag[0] = calc(dx[0], dy[0]);\n"
"}\n"
"}\n"
"__kernel void __attribute__((reqd_work_group_size(16, 16, 1)))\n"
"calcMagnitude_buf\n"
"(__global const short * dx_buf, int dx_buf_step, int dx_buf_offset,\n"
"__global const short * dy_buf, int dy_buf_step, int dy_buf_offset,\n"
"__global short * dx, int dx_step, int dx_offset,\n"
"__global short * dy, int dy_step, int dy_offset,\n"
"__global int * mag, int mag_step, int mag_offset,\n"
"int rows, int cols)\n"
"{\n"
"dx_buf_step    /= sizeof(*dx_buf);\n"
"dx_buf_offset  /= sizeof(*dx_buf);\n"
"dy_buf_step    /= sizeof(*dy_buf);\n"
"dy_buf_offset  /= sizeof(*dy_buf);\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local short sdx[18][16];\n"
"__local short sdy[18][16];\n"
"sdx[lidy + 1][lidx] = dx_buf[gidx + min(gidy, rows - 1) * dx_buf_step + dx_buf_offset];\n"
"sdy[lidy + 1][lidx] = dy_buf[gidx + min(gidy, rows - 1) * dy_buf_step + dy_buf_offset];\n"
"if (lidy == 0)\n"
"{\n"
"sdx[0][lidx]  = dx_buf[gidx + min(max(gidy - 1, 0), rows - 1) * dx_buf_step + dx_buf_offset];\n"
"sdx[17][lidx] = dx_buf[gidx + min(gidy + 16, rows - 1)        * dx_buf_step + dx_buf_offset];\n"
"sdy[0][lidx]  = dy_buf[gidx + min(max(gidy - 1, 0), rows - 1) * dy_buf_step + dy_buf_offset];\n"
"sdy[17][lidx] = dy_buf[gidx + min(gidy + 16, rows - 1)        * dy_buf_step + dy_buf_offset];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidx < cols && gidy < rows)\n"
"{\n"
"short x =  sdx[lidy][lidx] + 2 * sdx[lidy + 1][lidx] + sdx[lidy + 2][lidx];\n"
"short y = -sdy[lidy][lidx] + sdy[lidy + 2][lidx];\n"
"dx[gidx + gidy * dx_step + dx_offset] = x;\n"
"dy[gidx + gidy * dy_step + dy_offset] = y;\n"
"mag[(gidx + 1) + (gidy + 1) * mag_step + mag_offset] = calc(x, y);\n"
"}\n"
"}\n"
"#define CANNY_SHIFT 15\n"
"#define TG22        (int)(0.4142135623730950488016887242097f*(1<<CANNY_SHIFT) + 0.5f)\n"
"__kernel void __attribute__((reqd_work_group_size(16,16,1)))\n"
"calcMap(\n"
"__global const uchar * dx, int dx_step, int dx_offset,\n"
"__global const uchar * dy, int dy_step, int dy_offset,\n"
"__global const uchar * mag, int mag_step, int mag_offset,\n"
"__global uchar * map, int map_step, int map_offset,\n"
"int rows, int cols, int low_thresh, int high_thresh)\n"
"{\n"
"__local int smem[18][18];\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int grp_idx = get_global_id(0) & 0xFFFFF0;\n"
"int grp_idy = get_global_id(1) & 0xFFFFF0;\n"
"int tid = lidx + lidy * 16;\n"
"int lx = tid % 18;\n"
"int ly = tid / 18;\n"
"mag += mag_offset;\n"
"if (ly < 14)\n"
"smem[ly][lx] = *(__global const int *)(mag +\n"
"mad24(mag_step, min(grp_idy + ly, rows - 1), (int)sizeof(int) * (grp_idx + lx)));\n"
"if (ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n"
"smem[ly + 14][lx] = *(__global const int *)(mag +\n"
"mad24(mag_step, min(grp_idy + ly + 14, rows - 1), (int)sizeof(int) * (grp_idx + lx)));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidy < rows && gidx < cols)\n"
"{\n"
"int edge_type = 0;\n"
"int m = smem[lidy + 1][lidx + 1];\n"
"if (m > low_thresh)\n"
"{\n"
"short xs = *(__global const short *)(dx + mad24(gidy, dx_step, dx_offset + (int)sizeof(short) * gidx));\n"
"short ys = *(__global const short *)(dy + mad24(gidy, dy_step, dy_offset + (int)sizeof(short) * gidx));\n"
"int x = abs(xs), y = abs(ys);\n"
"int tg22x = x * TG22;\n"
"y <<= CANNY_SHIFT;\n"
"if (y < tg22x)\n"
"{\n"
"if (m > smem[lidy + 1][lidx] && m >= smem[lidy + 1][lidx + 2])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"else\n"
"{\n"
"int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\n"
"if (y > tg67x)\n"
"{\n"
"if (m > smem[lidy][lidx + 1]&& m >= smem[lidy + 2][lidx + 1])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"else\n"
"{\n"
"int s = (xs ^ ys) < 0 ? -1 : 1;\n"
"if (m > smem[lidy][lidx + 1 - s]&& m > smem[lidy + 2][lidx + 1 + s])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"}\n"
"*(__global int *)(map + mad24(map_step, gidy + 1, (gidx + 1) * (int)sizeof(int) + map_offset)) = edge_type;\n"
"}\n"
"}\n"
"#undef CANNY_SHIFT\n"
"#undef TG22\n"
"struct PtrStepSz\n"
"{\n"
"__global uchar * ptr;\n"
"int step, rows, cols;\n"
"};\n"
"inline int get(struct PtrStepSz data, int y, int x)\n"
"{\n"
"return *(__global int *)(data.ptr + mad24(data.step, y + 1, (int)sizeof(int) * (x + 1)));\n"
"}\n"
"inline void set(struct PtrStepSz data, int y, int x, int value)\n"
"{\n"
"*(__global int *)(data.ptr + mad24(data.step, y + 1, (int)sizeof(int) * (x + 1))) = value;\n"
"}\n"
"__kernel void __attribute__((reqd_work_group_size(16,16,1)))\n"
"edgesHysteresisLocal\n"
"(__global uchar * map_ptr, int map_step, int map_offset,\n"
"__global ushort2 * st, __global unsigned int * counter,\n"
"int rows, int cols)\n"
"{\n"
"struct PtrStepSz map = { map_ptr + map_offset, map_step, rows + 1, cols + 1 };\n"
"__local int smem[18][18];\n"
"int2 blockIdx = (int2)(get_group_id(0), get_group_id(1));\n"
"int2 blockDim = (int2)(get_local_size(0), get_local_size(1));\n"
"int2 threadIdx = (int2)(get_local_id(0), get_local_id(1));\n"
"const int x = blockIdx.x * blockDim.x + threadIdx.x;\n"
"const int y = blockIdx.y * blockDim.y + threadIdx.y;\n"
"smem[threadIdx.y + 1][threadIdx.x + 1] = x < map.cols && y < map.rows ? get(map, y, x) : 0;\n"
"if (threadIdx.y == 0)\n"
"smem[0][threadIdx.x + 1] = x < map.cols ? get(map, y - 1, x) : 0;\n"
"if (threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][threadIdx.x + 1] = y + 1 < map.rows ? get(map, y + 1, x) : 0;\n"
"if (threadIdx.x == 0)\n"
"smem[threadIdx.y + 1][0] = y < map.rows ? get(map, y, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1)\n"
"smem[threadIdx.y + 1][blockDim.x + 1] = x + 1 < map.cols && y < map.rows ? get(map, y, x + 1) : 0;\n"
"if (threadIdx.x == 0 && threadIdx.y == 0)\n"
"smem[0][0] = y > 0 && x > 0 ? get(map, y - 1, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1 && threadIdx.y == 0)\n"
"smem[0][blockDim.x + 1] = y > 0 && x + 1 < map.cols ? get(map, y - 1, x + 1) : 0;\n"
"if (threadIdx.x == 0 && threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][0] = y + 1 < map.rows && x > 0 ? get(map, y + 1, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1 && threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][blockDim.x + 1] = y + 1 < map.rows && x + 1 < map.cols ? get(map, y + 1, x + 1) : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (x >= cols || y >= rows)\n"
"return;\n"
"int n;\n"
"#pragma unroll\n"
"for (int k = 0; k < 16; ++k)\n"
"{\n"
"n = 0;\n"
"if (smem[threadIdx.y + 1][threadIdx.x + 1] == 1)\n"
"{\n"
"n += smem[threadIdx.y    ][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 1] == 2;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 2] == 2;\n"
"n += smem[threadIdx.y + 1][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y + 1][threadIdx.x + 2] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 1] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 2] == 2;\n"
"}\n"
"if (n > 0)\n"
"smem[threadIdx.y + 1][threadIdx.x + 1] = 2;\n"
"}\n"
"const int e = smem[threadIdx.y + 1][threadIdx.x + 1];\n"
"set(map, y, x, e);\n"
"n = 0;\n"
"if (e == 2)\n"
"{\n"
"n += smem[threadIdx.y    ][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 1] == 1;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 2] == 1;\n"
"n += smem[threadIdx.y + 1][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y + 1][threadIdx.x + 2] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 1] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 2] == 1;\n"
"}\n"
"if (n > 0)\n"
"{\n"
"const int ind = atomic_inc(counter);\n"
"st[ind] = (ushort2)(x + 1, y + 1);\n"
"}\n"
"}\n"
"__constant int c_dx[8] = {-1,  0,  1, -1, 1, -1, 0, 1};\n"
"__constant int c_dy[8] = {-1, -1, -1,  0, 0,  1, 1, 1};\n"
"#define stack_size 512\n"
"#define map_index mad24(map_step, pos.y, pos.x * (int)sizeof(int))\n"
"__kernel void __attribute__((reqd_work_group_size(128, 1, 1)))\n"
"edgesHysteresisGlobal(__global uchar * map, int map_step, int map_offset,\n"
"__global ushort2 * st1, __global ushort2 * st2, __global int * counter,\n"
"int rows, int cols, int count)\n"
"{\n"
"map += map_offset;\n"
"int lidx = get_local_id(0);\n"
"int grp_idx = get_group_id(0);\n"
"int grp_idy = get_group_id(1);\n"
"__local unsigned int s_counter, s_ind;\n"
"__local ushort2 s_st[stack_size];\n"
"if (lidx == 0)\n"
"s_counter = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ind = mad24(grp_idy, (int)get_local_size(0), grp_idx);\n"
"if (ind < count)\n"
"{\n"
"ushort2 pos = st1[ind];\n"
"if (lidx < 8)\n"
"{\n"
"pos.x += c_dx[lidx];\n"
"pos.y += c_dy[lidx];\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && *(__global int *)(map + map_index) == 1)\n"
"{\n"
"*(__global int *)(map + map_index) = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"while (s_counter > 0 && s_counter <= stack_size - get_local_size(0))\n"
"{\n"
"const int subTaskIdx = lidx >> 3;\n"
"const int portion = min(s_counter, (uint)(get_local_size(0)>> 3));\n"
"if (subTaskIdx < portion)\n"
"pos = s_st[s_counter - 1 - subTaskIdx];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"s_counter -= portion;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (subTaskIdx < portion)\n"
"{\n"
"pos.x += c_dx[lidx & 7];\n"
"pos.y += c_dy[lidx & 7];\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && *(__global int *)(map + map_index) == 1)\n"
"{\n"
"*(__global int *)(map + map_index) = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (s_counter > 0)\n"
"{\n"
"if (lidx == 0)\n"
"{\n"
"ind = atomic_add(counter, s_counter);\n"
"s_ind = ind - s_counter;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ind = s_ind;\n"
"for (int i = lidx; i < (int)s_counter; i += get_local_size(0))\n"
"st2[ind + i] = s_st[i];\n"
"}\n"
"}\n"
"}\n"
"#undef map_index\n"
"#undef stack_size\n"
"__kernel void getEdges(__global const uchar * mapptr, int map_step, int map_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int map_index = mad24(map_step, y + 1, (x + 1) * (int)sizeof(int) + map_offset);\n"
"int dst_index = mad24(dst_step, y, x + dst_offset);\n"
"__global const int * map = (__global const int *)(mapptr + map_index);\n"
"dst[dst_index] = (uchar)(-(map[0] >> 1));\n"
"}\n"
"}\n"
, "af69185178c6f8225774b5b044d1dafa"};
ProgramSource canny_oclsrc(canny.programStr);
const struct ProgramEntry clahe={"clahe",
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"inline int calc_lut(__local int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid == 0)\n"
"for (int i = 1; i < 256; ++i)\n"
"smem[i] += smem[i - 1];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"return smem[tid];\n"
"}\n"
"#ifdef CPU\n"
"inline void reduce(volatile __local int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 128)\n"
"smem[tid] = val += smem[tid + 128];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 64)\n"
"smem[tid] = val += smem[tid + 64];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"smem[tid] += smem[tid + 32];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"smem[tid] += smem[tid + 16];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"smem[tid] += smem[tid + 8];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"smem[tid] += smem[tid + 4];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"smem[tid] += smem[tid + 2];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"smem[256] = smem[tid] + smem[tid + 1];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"#else\n"
"inline void reduce(__local volatile int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 128)\n"
"smem[tid] = val += smem[tid + 128];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 64)\n"
"smem[tid] = val += smem[tid + 64];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"smem[tid] += smem[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"} barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 16];\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 8];\n"
"smem[tid] += smem[tid + 4];\n"
"smem[tid] += smem[tid + 2];\n"
"smem[tid] += smem[tid + 1];\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void calcLut(__global __const uchar * src, const int srcStep,\n"
"const int src_offset, __global uchar * lut,\n"
"const int dstStep, const int dst_offset,\n"
"const int2 tileSize, const int tilesX,\n"
"const int clipLimit, const float lutScale)\n"
"{\n"
"__local int smem[512];\n"
"int tx = get_group_id(0);\n"
"int ty = get_group_id(1);\n"
"int tid = get_local_id(1) * get_local_size(0)\n"
"+ get_local_id(0);\n"
"smem[tid] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int i = get_local_id(1); i < tileSize.y; i += get_local_size(1))\n"
"{\n"
"__global const uchar* srcPtr = src + mad24(ty * tileSize.y + i, srcStep, tx * tileSize.x + src_offset);\n"
"for (int j = get_local_id(0); j < tileSize.x; j += get_local_size(0))\n"
"{\n"
"const int data = srcPtr[j];\n"
"atomic_inc(&smem[data]);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int tHistVal = smem[tid];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (clipLimit > 0)\n"
"{\n"
"int clipped = 0;\n"
"if (tHistVal > clipLimit)\n"
"{\n"
"clipped = tHistVal - clipLimit;\n"
"tHistVal = clipLimit;\n"
"}\n"
"reduce(smem, clipped, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef CPU\n"
"clipped = smem[256];\n"
"#else\n"
"clipped = smem[0];\n"
"#endif\n"
"__local int totalClipped;\n"
"if (tid == 0)\n"
"totalClipped = clipped;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int redistBatch = totalClipped / 256;\n"
"tHistVal += redistBatch;\n"
"int residual = totalClipped - redistBatch * 256;\n"
"if (tid < residual)\n"
"++tHistVal;\n"
"}\n"
"const int lutVal = calc_lut(smem, tHistVal, tid);\n"
"uint ires = (uint)convert_int_rte(lutScale * lutVal);\n"
"lut[(ty * tilesX + tx) * dstStep + tid + dst_offset] =\n"
"convert_uchar(clamp(ires, (uint)0, (uint)255));\n"
"}\n"
"__kernel void transform(__global __const uchar * src, const int srcStep, const int src_offset,\n"
"__global uchar * dst, const int dstStep, const int dst_offset,\n"
"__global uchar * lut, const int lutStep, int lut_offset,\n"
"const int cols, const int rows,\n"
"const int2 tileSize,\n"
"const int tilesX, const int tilesY)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x >= cols || y >= rows)\n"
"return;\n"
"const float tyf = (convert_float(y) / tileSize.y) - 0.5f;\n"
"int ty1 = convert_int_rtn(tyf);\n"
"int ty2 = ty1 + 1;\n"
"const float ya = tyf - ty1;\n"
"ty1 = max(ty1, 0);\n"
"ty2 = min(ty2, tilesY - 1);\n"
"const float txf = (convert_float(x) / tileSize.x) - 0.5f;\n"
"int tx1 = convert_int_rtn(txf);\n"
"int tx2 = tx1 + 1;\n"
"const float xa = txf - tx1;\n"
"tx1 = max(tx1, 0);\n"
"tx2 = min(tx2, tilesX - 1);\n"
"const int srcVal = src[mad24(y, srcStep, x + src_offset)];\n"
"float res = 0;\n"
"res += lut[mad24(ty1 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (1.0f - ya));\n"
"res += lut[mad24(ty1 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (1.0f - ya));\n"
"res += lut[mad24(ty2 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (ya));\n"
"res += lut[mad24(ty2 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (ya));\n"
"uint ires = (uint)convert_int_rte(res);\n"
"dst[mad24(y, dstStep, x + dst_offset)] = convert_uchar(clamp(ires, (uint)0, (uint)255));\n"
"}\n"
, "1240500336efb8988a25b1da384c217d"};
ProgramSource clahe_oclsrc(clahe.programStr);
const struct ProgramEntry corner={"corner",
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"x = max(min(x, maxV - 1), 0); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"if (x < 0) \\\n"
"x -= ((x - maxV + 1) / maxV) * maxV; \\\n"
"if (x >= maxV) \\\n"
"x %= maxV; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT101)\n"
"#define EXTRAPOLATE_(x, maxV, delta) \\\n"
"{ \\\n"
"if (maxV == 1) \\\n"
"x = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if ( x < 0 ) \\\n"
"x = -x - 1 + delta; \\\n"
"else \\\n"
"x = maxV - 1 - (x - maxV) - delta; \\\n"
"} \\\n"
"while (x >= maxV || x < 0); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n"
"#else\n"
"#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define THREADS 256\n"
"__kernel void corner(__global const float * Dx, int dx_step, int dx_offset, int dx_whole_rows, int dx_whole_cols,\n"
"__global const float * Dy, int dy_step, int dy_offset, int dy_whole_rows, int dy_whole_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols, float k)\n"
"{\n"
"int col = get_local_id(0);\n"
"int gX = get_group_id(0);\n"
"int gY = get_group_id(1);\n"
"int gly = get_global_id(1);\n"
"int dx_x_off = (dx_offset % dx_step) >> 2;\n"
"int dx_y_off = dx_offset / dx_step;\n"
"int dy_x_off = (dy_offset % dy_step) >> 2;\n"
"int dy_y_off = dy_offset / dy_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\n"
"int dx_startY = (gY << 1) - anY + dx_y_off;\n"
"int dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\n"
"int dy_startY = (gY << 1) - anY + dy_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"float dx_data[ksY+1],dy_data[ksY+1], data[3][ksY+1];\n"
"__local float temp[6][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"for (int i=0; i < ksY+1; i++)\n"
"{\n"
"bool dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\n"
"int indexDx = (dx_startY+i)*(dx_step>>2)+(dx_startX+col);\n"
"float dx_s = dx_con ? Dx[indexDx] : 0.0f;\n"
"dx_data[i] = dx_s;\n"
"bool dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\n"
"int indexDy = (dy_startY+i)*(dy_step>>2)+(dy_startX+col);\n"
"float dy_s = dy_con ? Dy[indexDy] : 0.0f;\n"
"dy_data[i] = dy_s;\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#else\n"
"int clamped_col = min(2*dst_cols, col);\n"
"for (int i=0; i < ksY+1; i++)\n"
"{\n"
"int dx_selected_row = dx_startY+i, dx_selected_col = dx_startX+clamped_col;\n"
"EXTRAPOLATE(dx_selected_row, dx_whole_rows)\n"
"EXTRAPOLATE(dx_selected_col, dx_whole_cols)\n"
"dx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\n"
"int dy_selected_row = dy_startY+i, dy_selected_col = dy_startX+clamped_col;\n"
"EXTRAPOLATE(dy_selected_row, dy_whole_rows)\n"
"EXTRAPOLATE(dy_selected_col, dy_whole_cols)\n"
"dy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#endif\n"
"float sum0 = 0.0f, sum1 = 0.0f, sum2 = 0.0f;\n"
"for (int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += data[0][i];\n"
"sum1 += data[1][i];\n"
"sum2 += data[2][i];\n"
"}\n"
"float sum01 = sum0 + data[0][0];\n"
"float sum02 = sum0 + data[0][ksY];\n"
"temp[0][col] = sum01;\n"
"temp[1][col] = sum02;\n"
"float sum11 = sum1 + data[1][0];\n"
"float sum12 = sum1 + data[1][ksY];\n"
"temp[2][col] = sum11;\n"
"temp[3][col] = sum12;\n"
"float sum21 = sum2 + data[2][0];\n"
"float sum22 = sum2 + data[2][ksY];\n"
"temp[4][col] = sum21;\n"
"temp[5][col] = sum22;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (col < (THREADS - (ksX - 1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gly << 1);\n"
"int till = (ksX + 1)%2;\n"
"float tmp_sum[6] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };\n"
"for (int k=0; k<6; k++)\n"
"{\n"
"float temp_sum = 0;\n"
"for (int i=-anX; i<=anX - till; i++)\n"
"temp_sum += temp[k][col+i];\n"
"tmp_sum[k] = temp_sum;\n"
"}\n"
"#ifdef CORNER_HARRIS\n"
"if (posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY, (int)sizeof(float) * (dst_startX + col - anX));\n"
"*(__global float *)(dst + dst_index) =\n"
"tmp_sum[0] * tmp_sum[4] - tmp_sum[2] * tmp_sum[2] - k * (tmp_sum[0] + tmp_sum[4]) * (tmp_sum[0] + tmp_sum[4]);\n"
"}\n"
"if (posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY + 1, (int)sizeof(float) * (dst_startX + col - anX));\n"
"*(__global float *)(dst + dst_index) =\n"
"tmp_sum[1] * tmp_sum[5] - tmp_sum[3] * tmp_sum[3] - k * (tmp_sum[1] + tmp_sum[5]) * (tmp_sum[1] + tmp_sum[5]);\n"
"}\n"
"#elif defined CORNER_MINEIGENVAL\n"
"if (posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY, (int)sizeof(float) * (dst_startX + col - anX));\n"
"float a = tmp_sum[0] * 0.5f;\n"
"float b = tmp_sum[2];\n"
"float c = tmp_sum[4] * 0.5f;\n"
"*(__global float *)(dst + dst_index) = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"if (posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY + 1, (int)sizeof(float) * (dst_startX + col - anX));\n"
"float a = tmp_sum[1] * 0.5f;\n"
"float b = tmp_sum[3];\n"
"float c = tmp_sum[5] * 0.5f;\n"
"*(__global float *)(dst + dst_index) = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"#else\n"
"#error \"No such corners type\"\n"
"#endif\n"
"}\n"
"}\n"
, "cd6c97339f3c3fd6ed35f0e0f0b4ed1a"};
ProgramSource corner_oclsrc(corner.programStr);
const struct ProgramEntry cvtcolor={"cvtcolor",
"#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#if depth == 0\n"
"#define DATA_TYPE uchar\n"
"#define MAX_NUM  255\n"
"#define HALF_MAX 128\n"
"#define COEFF_TYPE int\n"
"#define SAT_CAST(num) convert_uchar_sat(num)\n"
"#define DEPTH_0\n"
"#elif depth == 2\n"
"#define DATA_TYPE ushort\n"
"#define MAX_NUM  65535\n"
"#define HALF_MAX 32768\n"
"#define COEFF_TYPE int\n"
"#define SAT_CAST(num) convert_ushort_sat(num)\n"
"#define DEPTH_2\n"
"#elif depth == 5\n"
"#define DATA_TYPE float\n"
"#define MAX_NUM  1.0f\n"
"#define HALF_MAX 0.5f\n"
"#define COEFF_TYPE float\n"
"#define SAT_CAST(num) (num)\n"
"#define DEPTH_5\n"
"#else\n"
"#error \"invalid depth: should be 0 (CV_8U), 2 (CV_16U) or 5 (CV_32F)\"\n"
"#endif\n"
"#ifndef STRIPE_SIZE\n"
"#define STRIPE_SIZE 1\n"
"#endif\n"
"#define CV_DESCALE(x,n) (((x) + (1 << ((n)-1))) >> (n))\n"
"enum\n"
"{\n"
"yuv_shift  = 14,\n"
"xyz_shift  = 12,\n"
"hsv_shift = 12,\n"
"R2Y        = 4899,\n"
"G2Y        = 9617,\n"
"B2Y        = 1868,\n"
"BLOCK_SIZE = 256\n"
"};\n"
"#define scnbytes ((int)sizeof(DATA_TYPE)*scn)\n"
"#define dcnbytes ((int)sizeof(DATA_TYPE)*dcn)\n"
"#ifndef hscale\n"
"#define hscale 0\n"
"#endif\n"
"#ifndef hrange\n"
"#define hrange 0\n"
"#endif\n"
"__kernel void RGB2Gray(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"#if 1\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"#ifdef DEPTH_5\n"
"dst[0] = src[bidx] * 0.114f + src[1] * 0.587f + src[(bidx^2)] * 0.299f;\n"
"#else\n"
"dst[0] = (DATA_TYPE)CV_DESCALE((src[bidx] * B2Y + src[1] * G2Y + src[(bidx^2)] * R2Y), yuv_shift);\n"
"#endif\n"
"}\n"
"#else\n"
"const int x_min = get_global_id(0)*STRIPE_SIZE;\n"
"const int x_max = min(x_min + STRIPE_SIZE, cols);\n"
"const int y = get_global_id(1);\n"
"if( y < rows )\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr +\n"
"mad24(y, srcstep, srcoffset)) + x_min*scn;\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset));\n"
"int x;\n"
"for( x = x_min; x < x_max; x++, src += scn )\n"
"#ifdef DEPTH_5\n"
"dst[x] = src[bidx] * 0.114f + src[1] * 0.587f + src[(bidx^2)] * 0.299f;\n"
"#else\n"
"dst[x] = (DATA_TYPE)(mad24(src[bidx], B2Y, mad24(src[1], G2Y,\n"
"mad24(src[(bidx^2)], R2Y, 1 << (yuv_shift-1)))) >> yuv_shift);\n"
"#endif\n"
"}\n"
"#endif\n"
"}\n"
"__kernel void Gray2RGB(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE val = src[0];\n"
"dst[0] = dst[1] = dst[2] = val;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"__constant float c_RGB2YUVCoeffs_f[5]  = { 0.114f, 0.587f, 0.299f, 0.492f, 0.877f };\n"
"__constant int   c_RGB2YUVCoeffs_i[5]  = { B2Y, G2Y, R2Y, 8061, 14369 };\n"
"__kernel void RGB2YUV(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE b=src[bidx], g=src[1], r=src[bidx^2];\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_RGB2YUVCoeffs_f;\n"
"const DATA_TYPE Y  = b * coeffs[0] + g * coeffs[1] + r * coeffs[2];\n"
"const DATA_TYPE U = (b - Y) * coeffs[3] + HALF_MAX;\n"
"const DATA_TYPE V = (r - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YUVCoeffs_i;\n"
"const int delta = HALF_MAX * (1 << yuv_shift);\n"
"const int Y = CV_DESCALE(b * coeffs[0] + g * coeffs[1] + r * coeffs[2], yuv_shift);\n"
"const int U = CV_DESCALE((b - Y) * coeffs[3] + delta, yuv_shift);\n"
"const int V = CV_DESCALE((r - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( U );\n"
"dst[2] = SAT_CAST( V );\n"
"}\n"
"}\n"
"__constant float c_YUV2RGBCoeffs_f[5] = { 2.032f, -0.395f, -0.581f, 1.140f };\n"
"__constant int   c_YUV2RGBCoeffs_i[5] = { 33292, -6472, -9519, 18678 };\n"
"__kernel void YUV2RGB(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE Y = src[0], U = src[1], V = src[2];\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_YUV2RGBCoeffs_f;\n"
"const float r = Y + (V - HALF_MAX) * coeffs[3];\n"
"const float g = Y + (V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1];\n"
"const float b = Y + (U - HALF_MAX) * coeffs[0];\n"
"#else\n"
"__constant int * coeffs = c_YUV2RGBCoeffs_i;\n"
"const int r = Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift);\n"
"const int g = Y + CV_DESCALE((V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1], yuv_shift);\n"
"const int b = Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift);\n"
"#endif\n"
"dst[bidx] = SAT_CAST( b );\n"
"dst[1] = SAT_CAST( g );\n"
"dst[bidx^2] = SAT_CAST( r );\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"__constant int ITUR_BT_601_CY = 1220542;\n"
"__constant int ITUR_BT_601_CUB = 2116026;\n"
"__constant int ITUR_BT_601_CUG = 409993;\n"
"__constant int ITUR_BT_601_CVG = 852492;\n"
"__constant int ITUR_BT_601_CVR = 1673527;\n"
"__constant int ITUR_BT_601_SHIFT = 20;\n"
"__kernel void YUV2RGB_NV12(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows / 2 && x < cols / 2 )\n"
"{\n"
"__global const uchar* ysrc = srcptr + mad24(y << 1, srcstep, (x << 1) + srcoffset);\n"
"__global const uchar* usrc = srcptr + mad24(rows + y, srcstep, (x << 1) + srcoffset);\n"
"__global uchar*       dst1 = dstptr + mad24(y << 1, dststep, x * (dcn<<1) + dstoffset);\n"
"__global uchar*       dst2 = dstptr + mad24((y << 1) + 1, dststep, x * (dcn<<1) + dstoffset);\n"
"int Y1 = ysrc[0];\n"
"int Y2 = ysrc[1];\n"
"int Y3 = ysrc[srcstep];\n"
"int Y4 = ysrc[srcstep + 1];\n"
"int U  = usrc[0] - 128;\n"
"int V  = usrc[1] - 128;\n"
"int ruv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CVR * V;\n"
"int guv = (1 << (ITUR_BT_601_SHIFT - 1)) - ITUR_BT_601_CVG * V - ITUR_BT_601_CUG * U;\n"
"int buv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CUB * U;\n"
"Y1 = max(0, Y1 - 16) * ITUR_BT_601_CY;\n"
"dst1[2 - bidx]     = convert_uchar_sat((Y1 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[1]        = convert_uchar_sat((Y1 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[bidx] = convert_uchar_sat((Y1 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst1[3]        = 255;\n"
"#endif\n"
"Y2 = max(0, Y2 - 16) * ITUR_BT_601_CY;\n"
"dst1[dcn + 2 - bidx] = convert_uchar_sat((Y2 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[dcn + 1]        = convert_uchar_sat((Y2 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[dcn + bidx] = convert_uchar_sat((Y2 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst1[7]        = 255;\n"
"#endif\n"
"Y3 = max(0, Y3 - 16) * ITUR_BT_601_CY;\n"
"dst2[2 - bidx]     = convert_uchar_sat((Y3 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[1]        = convert_uchar_sat((Y3 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[bidx] = convert_uchar_sat((Y3 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst2[3]        = 255;\n"
"#endif\n"
"Y4 = max(0, Y4 - 16) * ITUR_BT_601_CY;\n"
"dst2[dcn + 2 - bidx] = convert_uchar_sat((Y4 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[dcn + 1]        = convert_uchar_sat((Y4 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[dcn + bidx] = convert_uchar_sat((Y4 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst2[7]        = 255;\n"
"#endif\n"
"}\n"
"}\n"
"__constant float c_RGB2YCrCbCoeffs_f[5] = {0.299f, 0.587f, 0.114f, 0.713f, 0.564f};\n"
"__constant int   c_RGB2YCrCbCoeffs_i[5] = {R2Y, G2Y, B2Y, 11682, 9241};\n"
"__kernel void RGB2YCrCb(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE b=src[bidx], g=src[1], r=src[bidx^2];\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_RGB2YCrCbCoeffs_f;\n"
"DATA_TYPE Y = b * coeffs[2] + g * coeffs[1] + r * coeffs[0];\n"
"DATA_TYPE Cr = (r - Y) * coeffs[3] + HALF_MAX;\n"
"DATA_TYPE Cb = (b - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YCrCbCoeffs_i;\n"
"int delta = HALF_MAX * (1 << yuv_shift);\n"
"int Y =  CV_DESCALE(b * coeffs[2] + g * coeffs[1] + r * coeffs[0], yuv_shift);\n"
"int Cr = CV_DESCALE((r - Y) * coeffs[3] + delta, yuv_shift);\n"
"int Cb = CV_DESCALE((b - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( Cr );\n"
"dst[2] = SAT_CAST( Cb );\n"
"}\n"
"}\n"
"__constant float c_YCrCb2RGBCoeffs_f[4] = { 1.403f, -0.714f, -0.344f, 1.773f };\n"
"__constant int   c_YCrCb2RGBCoeffs_i[4] = { 22987, -11698, -5636, 29049 };\n"
"__kernel void YCrCb2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const DATA_TYPE * srcptr = (__global const DATA_TYPE*)(src + src_idx);\n"
"__global DATA_TYPE * dstptr = (__global DATA_TYPE*)(dst + dst_idx);\n"
"DATA_TYPE y = srcptr[0], cr = srcptr[1], cb = srcptr[2];\n"
"#ifdef DEPTH_5\n"
"__constant float * coeff = c_YCrCb2RGBCoeffs_f;\n"
"float r = y + coeff[0] * (cr - HALF_MAX);\n"
"float g = y + coeff[1] * (cr - HALF_MAX) + coeff[2] * (cb - HALF_MAX);\n"
"float b = y + coeff[3] * (cb - HALF_MAX);\n"
"#else\n"
"__constant int * coeff = c_YCrCb2RGBCoeffs_i;\n"
"int r = y + CV_DESCALE(coeff[0] * (cr - HALF_MAX), yuv_shift);\n"
"int g = y + CV_DESCALE(coeff[1] * (cr - HALF_MAX) + coeff[2] * (cb - HALF_MAX), yuv_shift);\n"
"int b = y + CV_DESCALE(coeff[3] * (cb - HALF_MAX), yuv_shift);\n"
"#endif\n"
"dstptr[(bidx^2)] = SAT_CAST(r);\n"
"dstptr[1] = SAT_CAST(g);\n"
"dstptr[bidx] = SAT_CAST(b);\n"
"#if dcn == 4\n"
"dstptr[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void RGB2XYZ(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols, __constant COEFF_TYPE * coeffs)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dy < rows && dx < cols)\n"
"{\n"
"int src_idx = mad24(dy, src_step, src_offset + dx * scnbytes);\n"
"int dst_idx = mad24(dy, dst_step, dst_offset + dx * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"DATA_TYPE r = src[0], g = src[1], b = src[2];\n"
"#ifdef DEPTH_5\n"
"float x = r * coeffs[0] + g * coeffs[1] + b * coeffs[2];\n"
"float y = r * coeffs[3] + g * coeffs[4] + b * coeffs[5];\n"
"float z = r * coeffs[6] + g * coeffs[7] + b * coeffs[8];\n"
"#else\n"
"int x = CV_DESCALE(r * coeffs[0] + g * coeffs[1] + b * coeffs[2], xyz_shift);\n"
"int y = CV_DESCALE(r * coeffs[3] + g * coeffs[4] + b * coeffs[5], xyz_shift);\n"
"int z = CV_DESCALE(r * coeffs[6] + g * coeffs[7] + b * coeffs[8], xyz_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST(x);\n"
"dst[1] = SAT_CAST(y);\n"
"dst[2] = SAT_CAST(z);\n"
"}\n"
"}\n"
"__kernel void XYZ2RGB(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols, __constant COEFF_TYPE * coeffs)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dy < rows && dx < cols)\n"
"{\n"
"int src_idx = mad24(dy, src_step, src_offset + dx * scnbytes);\n"
"int dst_idx = mad24(dy, dst_step, dst_offset + dx * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"DATA_TYPE x = src[0], y = src[1], z = src[2];\n"
"#ifdef DEPTH_5\n"
"float b = x * coeffs[0] + y * coeffs[1] + z * coeffs[2];\n"
"float g = x * coeffs[3] + y * coeffs[4] + z * coeffs[5];\n"
"float r = x * coeffs[6] + y * coeffs[7] + z * coeffs[8];\n"
"#else\n"
"int b = CV_DESCALE(x * coeffs[0] + y * coeffs[1] + z * coeffs[2], xyz_shift);\n"
"int g = CV_DESCALE(x * coeffs[3] + y * coeffs[4] + z * coeffs[5], xyz_shift);\n"
"int r = CV_DESCALE(x * coeffs[6] + y * coeffs[7] + z * coeffs[8], xyz_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST(b);\n"
"dst[1] = SAT_CAST(g);\n"
"dst[2] = SAT_CAST(r);\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"#ifdef REVERSE\n"
"dst[0] = src[2];\n"
"dst[1] = src[1];\n"
"dst[2] = src[0];\n"
"#else\n"
"dst[0] = src[0];\n"
"dst[1] = src[1];\n"
"dst[2] = src[2];\n"
"#endif\n"
"#if dcn == 4\n"
"#if scn == 3\n"
"dst[3] = MAX_NUM;\n"
"#else\n"
"dst[3] = src[3];\n"
"#endif\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void RGB5x52RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"ushort t = *((__global const ushort*)(src + src_idx));\n"
"#if greenbits == 6\n"
"dst[dst_idx + bidx] = (uchar)(t << 3);\n"
"dst[dst_idx + 1] = (uchar)((t >> 3) & ~3);\n"
"dst[dst_idx + (bidx^2)] = (uchar)((t >> 8) & ~7);\n"
"#else\n"
"dst[dst_idx + bidx] = (uchar)(t << 3);\n"
"dst[dst_idx + 1] = (uchar)((t >> 2) & ~7);\n"
"dst[dst_idx + (bidx^2)] = (uchar)((t >> 7) & ~7);\n"
"#endif\n"
"#if dcn == 4\n"
"#if greenbits == 6\n"
"dst[dst_idx + 3] = 255;\n"
"#else\n"
"dst[dst_idx + 3] = t & 0x8000 ? 255 : 0;\n"
"#endif\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void RGB2RGB5x5(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"#if greenbits == 6\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~3) << 3)|((src[src_idx + (bidx^2)]&~7) << 8));\n"
"#elif scn == 3\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~7) << 2)|((src[src_idx + (bidx^2)]&~7) << 7));\n"
"#else\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~7) << 2)|\n"
"((src[src_idx + (bidx^2)]&~7) << 7)|(src[src_idx + 3] ? 0x8000 : 0));\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void BGR5x52Gray(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x);\n"
"int t = *((__global const ushort*)(src + src_idx));\n"
"#if greenbits == 6\n"
"dst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n"
"((t >> 3) & 0xfc)*G2Y +\n"
"((t >> 8) & 0xf8)*R2Y, yuv_shift);\n"
"#else\n"
"dst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n"
"((t >> 2) & 0xf8)*G2Y +\n"
"((t >> 7) & 0xf8)*R2Y, yuv_shift);\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void Gray2BGR5x5(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"int t = src[src_idx];\n"
"#if greenbits == 6\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((t >> 3) | ((t & ~3) << 3) | ((t & ~7) << 8));\n"
"#else\n"
"t >>= 3;\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)(t|(t << 5)|(t << 10));\n"
"#endif\n"
"}\n"
"}\n"
"__constant int sector_data[][3] = { { 1, 3, 0 },\n"
"{ 1, 0, 2 },\n"
"{ 3, 0, 1 },\n"
"{ 0, 2, 1 },\n"
"{ 0, 1, 3 },\n"
"{ 2, 1, 0 } };\n"
"#ifdef DEPTH_0\n"
"__kernel void RGB2HSV(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols,\n"
"__constant int * sdiv_table, __constant int * hdiv_table)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"int b = src[src_idx + bidx], g = src[src_idx + 1], r = src[src_idx + (bidx^2)];\n"
"int h, s, v = b;\n"
"int vmin = b, diff;\n"
"int vr, vg;\n"
"v = max( v, g );\n"
"v = max( v, r );\n"
"vmin = min( vmin, g );\n"
"vmin = min( vmin, r );\n"
"diff = v - vmin;\n"
"vr = v == r ? -1 : 0;\n"
"vg = v == g ? -1 : 0;\n"
"s = (diff * sdiv_table[v] + (1 << (hsv_shift-1))) >> hsv_shift;\n"
"h = (vr & (g - b)) +\n"
"(~vr & ((vg & (b - r + 2 * diff)) + ((~vg) & (r - g + 4 * diff))));\n"
"h = (h * hdiv_table[diff] + (1 << (hsv_shift-1))) >> hsv_shift;\n"
"h += h < 0 ? hrange : 0;\n"
"dst[dst_idx] = convert_uchar_sat_rte(h);\n"
"dst[dst_idx + 1] = (uchar)s;\n"
"dst[dst_idx + 2] = (uchar)v;\n"
"}\n"
"}\n"
"__kernel void HSV2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"float h = src[src_idx], s = src[src_idx + 1]*(1/255.f), v = src[src_idx + 2]*(1/255.f);\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"if( (unsigned)sector >= 6u )\n"
"{\n"
"sector = 0;\n"
"h = 0.f;\n"
"}\n"
"tab[0] = v;\n"
"tab[1] = v*(1.f - s);\n"
"tab[2] = v*(1.f - s*h);\n"
"tab[3] = v*(1.f - s*(1.f - h));\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = v;\n"
"dst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\n"
"dst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n"
"#if dcn == 4\n"
"dst[dst_idx + 3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void RGB2HSV(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float b = src[bidx], g = src[1], r = src[bidx^2];\n"
"float h, s, v;\n"
"float vmin, diff;\n"
"v = vmin = r;\n"
"if( v < g ) v = g;\n"
"if( v < b ) v = b;\n"
"if( vmin > g ) vmin = g;\n"
"if( vmin > b ) vmin = b;\n"
"diff = v - vmin;\n"
"s = diff/(float)(fabs(v) + FLT_EPSILON);\n"
"diff = (float)(60.f/(diff + FLT_EPSILON));\n"
"if( v == r )\n"
"h = (g - b)*diff;\n"
"else if( v == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0 ) h += 360.f;\n"
"dst[0] = h*hscale;\n"
"dst[1] = s;\n"
"dst[2] = v;\n"
"}\n"
"}\n"
"__kernel void HSV2RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float h = src[0], s = src[1], v = src[2];\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"h *= hscale;\n"
"if(h < 0)\n"
"do h += 6; while (h < 0);\n"
"else if (h >= 6)\n"
"do h -= 6; while (h >= 6);\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"if ((unsigned)sector >= 6u)\n"
"{\n"
"sector = 0;\n"
"h = 0.f;\n"
"}\n"
"tab[0] = v;\n"
"tab[1] = v*(1.f - s);\n"
"tab[2] = v*(1.f - s*h);\n"
"tab[3] = v*(1.f - s*(1.f - h));\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = v;\n"
"dst[bidx] = b;\n"
"dst[1] = g;\n"
"dst[bidx^2] = r;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"__kernel void RGB2HLS(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"float b = src[src_idx + bidx]*(1/255.f), g = src[src_idx + 1]*(1/255.f), r = src[src_idx + (bidx^2)]*(1/255.f);\n"
"float h = 0.f, s = 0.f, l;\n"
"float vmin, vmax, diff;\n"
"vmax = vmin = r;\n"
"if (vmax < g) vmax = g;\n"
"if (vmax < b) vmax = b;\n"
"if (vmin > g) vmin = g;\n"
"if (vmin > b) vmin = b;\n"
"diff = vmax - vmin;\n"
"l = (vmax + vmin)*0.5f;\n"
"if (diff > FLT_EPSILON)\n"
"{\n"
"s = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\n"
"diff = 60.f/diff;\n"
"if( vmax == r )\n"
"h = (g - b)*diff;\n"
"else if( vmax == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0.f ) h += 360.f;\n"
"}\n"
"dst[dst_idx] = convert_uchar_sat_rte(h*hscale);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(l*255.f);\n"
"dst[dst_idx + 2] = convert_uchar_sat_rte(s*255.f);\n"
"}\n"
"}\n"
"__kernel void HLS2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"float h = src[src_idx], l = src[src_idx + 1]*(1.f/255.f), s = src[src_idx + 2]*(1.f/255.f);\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"float p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\n"
"float p1 = 2*l - p2;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"int sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"tab[0] = p2;\n"
"tab[1] = p1;\n"
"tab[2] = p1 + (p2 - p1)*(1-h);\n"
"tab[3] = p1 + (p2 - p1)*h;\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = l;\n"
"dst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\n"
"dst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n"
"#if dcn == 4\n"
"dst[dst_idx + 3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void RGB2HLS(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float b = src[bidx], g = src[1], r = src[bidx^2];\n"
"float h = 0.f, s = 0.f, l;\n"
"float vmin, vmax, diff;\n"
"vmax = vmin = r;\n"
"if (vmax < g) vmax = g;\n"
"if (vmax < b) vmax = b;\n"
"if (vmin > g) vmin = g;\n"
"if (vmin > b) vmin = b;\n"
"diff = vmax - vmin;\n"
"l = (vmax + vmin)*0.5f;\n"
"if (diff > FLT_EPSILON)\n"
"{\n"
"s = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\n"
"diff = 60.f/diff;\n"
"if( vmax == r )\n"
"h = (g - b)*diff;\n"
"else if( vmax == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0.f ) h += 360.f;\n"
"}\n"
"dst[0] = h*hscale;\n"
"dst[1] = l;\n"
"dst[2] = s;\n"
"}\n"
"}\n"
"__kernel void HLS2RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float h = src[0], l = src[1], s = src[2];\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"float p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\n"
"float p1 = 2*l - p2;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"tab[0] = p2;\n"
"tab[1] = p1;\n"
"tab[2] = p1 + (p2 - p1)*(1-h);\n"
"tab[3] = p1 + (p2 - p1)*h;\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = l;\n"
"dst[bidx] = b;\n"
"dst[1] = g;\n"
"dst[bidx^2] = r;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"__kernel void RGBA2mRGBA(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"x <<= 2;\n"
"int src_idx = mad24(y, src_step, src_offset + x);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x);\n"
"uchar v0 = src[src_idx], v1 = src[src_idx + 1];\n"
"uchar v2 = src[src_idx + 2], v3 = src[src_idx + 3];\n"
"dst[dst_idx] = (v0 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 1] = (v1 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 2] = (v2 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 3] = v3;\n"
"}\n"
"}\n"
"__kernel void mRGBA2RGBA(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"x <<= 2;\n"
"int src_idx = mad24(y, src_step, src_offset + x);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x);\n"
"uchar v0 = src[src_idx], v1 = src[src_idx + 1];\n"
"uchar v2 = src[src_idx + 2], v3 = src[src_idx + 3];\n"
"uchar v3_half = v3 / 2;\n"
"dst[dst_idx] = v3 == 0 ? 0 : (v0 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 1] = v3 == 0 ? 0 : (v1 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 2] = v3 == 0 ? 0 : (v2 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 3] = v3;\n"
"}\n"
"}\n"
"#endif\n"
, "69a102d750e9f77592a08709dfd2cd2d"};
ProgramSource cvtcolor_oclsrc(cvtcolor.programStr);
const struct ProgramEntry filter2D={"filter2D",
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#ifdef EXTRA_EXTRAPOLATION\n"
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"x = max(min(x, maxX - 1), minX); \\\n"
"y = max(min(y, maxY - 1), minY); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x -= ((x - maxX + 1) / maxX) * maxX; \\\n"
"if (x >= maxX) \\\n"
"x %= maxX; \\\n"
"if (y < minY) \\\n"
"y -= ((y - maxY + 1) / maxY) * maxY; \\\n"
"if (y >= maxY) \\\n"
"y %= maxY; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n"
"{ \\\n"
"if (maxX - minX == 1) \\\n"
"x = minX; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x = minX - (x - minX) - 1 + delta; \\\n"
"else \\\n"
"x = maxX - 1 - (x - maxX) - delta; \\\n"
"} \\\n"
"while (x >= maxX || x < minX); \\\n"
"\\\n"
"if (maxY - minY == 1) \\\n"
"y = minY; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (y < minY) \\\n"
"y = minY - (y - minY) - 1 + delta; \\\n"
"else \\\n"
"y = maxY - 1 - (y - maxY) - delta; \\\n"
"} \\\n"
"while (y >= maxY || y < minY); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n"
"#elif defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#else\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"int _row = y - minY, _col = x - minX; \\\n"
"_row = ADDR_H(_row, 0, maxY - minY); \\\n"
"_row = ADDR_B(_row, maxY - minY, _row); \\\n"
"y = _row + minY; \\\n"
"\\\n"
"_col = ADDR_L(_col, 0, maxX - minX); \\\n"
"_col = ADDR_R(_col, maxX - minX, _col); \\\n"
"x = _col + minX; \\\n"
"}\n"
"#endif\n"
"#if USE_DOUBLE\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define FPTYPE double\n"
"#define CONVERT_TO_FPTYPE CAT(convert_double, VEC_SIZE)\n"
"#else\n"
"#define FPTYPE float\n"
"#define CONVERT_TO_FPTYPE CAT(convert_float, VEC_SIZE)\n"
"#endif\n"
"#if DATA_DEPTH == 0\n"
"#define BASE_TYPE uchar\n"
"#elif DATA_DEPTH == 1\n"
"#define BASE_TYPE char\n"
"#elif DATA_DEPTH == 2\n"
"#define BASE_TYPE ushort\n"
"#elif DATA_DEPTH == 3\n"
"#define BASE_TYPE short\n"
"#elif DATA_DEPTH == 4\n"
"#define BASE_TYPE int\n"
"#elif DATA_DEPTH == 5\n"
"#define BASE_TYPE float\n"
"#elif DATA_DEPTH == 6\n"
"#define BASE_TYPE double\n"
"#else\n"
"#error data_depth\n"
"#endif\n"
"#define __CAT(x, y) x##y\n"
"#define CAT(x, y) __CAT(x, y)\n"
"#define uchar1 uchar\n"
"#define char1 char\n"
"#define ushort1 ushort\n"
"#define short1 short\n"
"#define int1 int\n"
"#define float1 float\n"
"#define double1 double\n"
"#define convert_uchar1_sat_rte convert_uchar_sat_rte\n"
"#define convert_char1_sat_rte convert_char_sat_rte\n"
"#define convert_ushort1_sat_rte convert_ushort_sat_rte\n"
"#define convert_short1_sat_rte convert_short_sat_rte\n"
"#define convert_int1_sat_rte convert_int_sat_rte\n"
"#define convert_float1\n"
"#define convert_double1\n"
"#if DATA_DEPTH == 5 || DATA_DEPTH == 6\n"
"#define CONVERT_TO_TYPE CAT(CAT(convert_, BASE_TYPE), VEC_SIZE)\n"
"#else\n"
"#define CONVERT_TO_TYPE CAT(CAT(CAT(convert_, BASE_TYPE), VEC_SIZE), _sat_rte)\n"
"#endif\n"
"#define VEC_SIZE DATA_CHAN\n"
"#define VEC_TYPE CAT(BASE_TYPE, VEC_SIZE)\n"
"#define TYPE VEC_TYPE\n"
"#define SCALAR_TYPE CAT(FPTYPE, VEC_SIZE)\n"
"#define INTERMEDIATE_TYPE CAT(FPTYPE, VEC_SIZE)\n"
"struct RectCoords\n"
"{\n"
"int x1, y1, x2, y2;\n"
"};\n"
"#ifdef DEBUG\n"
"#define DEBUG_ONLY(x) x\n"
"#define ASSERT(condition) do { if (!(condition)) { printf(\"BUG in boxFilter kernel (global=%d,%d): \" #condition \"\\n\", get_global_id(0), get_global_id(1)); } } while (0)\n"
"#else\n"
"#define DEBUG_ONLY(x) (void)0\n"
"#define ASSERT(condition) (void)0\n"
"#endif\n"
"inline INTERMEDIATE_TYPE readSrcPixel(int2 pos, __global const uchar* srcptr, int srcstep, const struct RectCoords srcCoords\n"
"#ifdef BORDER_CONSTANT\n"
", SCALAR_TYPE borderValue\n"
"#endif\n"
")\n"
"{\n"
"#ifdef BORDER_ISOLATED\n"
"if(pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#else\n"
"if(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#endif\n"
"{\n"
"__global TYPE* ptr = (__global TYPE*)(srcptr + pos.y * srcstep + pos.x * sizeof(TYPE));\n"
"return CONVERT_TO_FPTYPE(*ptr);\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"return borderValue;\n"
"#else\n"
"int selected_col = pos.x;\n"
"int selected_row = pos.y;\n"
"EXTRAPOLATE(selected_col, selected_row,\n"
"#ifdef BORDER_ISOLATED\n"
"srcCoords.x1, srcCoords.y1,\n"
"#else\n"
"0, 0,\n"
"#endif\n"
"srcCoords.x2, srcCoords.y2\n"
");\n"
"pos = (int2)(selected_col, selected_row);\n"
"if(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"{\n"
"__global TYPE* ptr = (__global TYPE*)(srcptr + pos.y * srcstep + pos.x * sizeof(TYPE));\n"
"return CONVERT_TO_FPTYPE(*ptr);\n"
"}\n"
"else\n"
"{\n"
"DEBUG_ONLY(printf(\"BUG in boxFilter kernel\\n\"));\n"
"return (FPTYPE)(0.0f);\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(LOCAL_SIZE, 1, 1)))\n"
"void filter2D(__global const uchar* srcptr, int srcstep, int srcOffsetX, int srcOffsetY, int srcEndX, int srcEndY,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols,\n"
"#ifdef BORDER_CONSTANT\n"
"SCALAR_TYPE borderValue,\n"
"#endif\n"
"__constant FPTYPE* kernelData\n"
")\n"
"{\n"
"const struct RectCoords srcCoords = {srcOffsetX, srcOffsetY, srcEndX, srcEndY};\n"
"const int local_id = get_local_id(0);\n"
"const int x = local_id + (LOCAL_SIZE - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\n"
"const int y = get_global_id(1) * BLOCK_SIZE_Y;\n"
"INTERMEDIATE_TYPE data[KERNEL_SIZE_Y];\n"
"__local INTERMEDIATE_TYPE sumOfCols[LOCAL_SIZE];\n"
"int2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\n"
"int2 pos = (int2)(x, y);\n"
"__global TYPE* dstPtr = (__global TYPE*)((__global char*)dstptr + pos.y * dststep + dstoffset + pos.x * sizeof(TYPE));\n"
"bool writeResult = ((local_id >= ANCHOR_X) && (local_id < LOCAL_SIZE - (KERNEL_SIZE_X - 1 - ANCHOR_X)) &&\n"
"(pos.x >= 0) && (pos.x < cols));\n"
"#if BLOCK_SIZE_Y > 1\n"
"bool readAllpixels = true;\n"
"int sy_index = 0;\n"
"dstRowsMax = min(rows, pos.y + BLOCK_SIZE_Y);\n"
"for (;\n"
"pos.y < dstRowsMax;\n"
"pos.y++,\n"
"dstPtr = (__global TYPE*)((__global char*)dstptr + dststep))\n"
"#endif\n"
"{\n"
"ASSERT(pos.y < dstRowsMax);\n"
"for (\n"
"#if BLOCK_SIZE_Y > 1\n"
"int sy = readAllpixels ? 0 : -1; sy < (readAllpixels ? KERNEL_SIZE_Y : 0);\n"
"#else\n"
"int sy = 0, sy_index = 0; sy < KERNEL_SIZE_Y;\n"
"#endif\n"
"sy++, srcPos.y++)\n"
"{\n"
"data[sy + sy_index] = readSrcPixel(srcPos, srcptr, srcstep, srcCoords\n"
"#ifdef BORDER_CONSTANT\n"
", borderValue\n"
"#endif\n"
");\n"
"}\n"
"INTERMEDIATE_TYPE total_sum = 0;\n"
"for (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n"
"{\n"
"{\n"
"__constant FPTYPE* k = &kernelData[KERNEL_SIZE_Y2_ALIGNED * sx\n"
"#if BLOCK_SIZE_Y > 1\n"
"+ KERNEL_SIZE_Y - sy_index\n"
"#endif\n"
"];\n"
"INTERMEDIATE_TYPE tmp_sum = 0;\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n"
"{\n"
"tmp_sum += data[sy] * k[sy];\n"
"}\n"
"sumOfCols[local_id] = tmp_sum;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"int id = local_id + sx - ANCHOR_X;\n"
"if (id >= 0 && id < LOCAL_SIZE)\n"
"total_sum += sumOfCols[id];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (writeResult)\n"
"{\n"
"*dstPtr = CONVERT_TO_TYPE(total_sum);\n"
"}\n"
"#if BLOCK_SIZE_Y > 1\n"
"readAllpixels = false;\n"
"#if BLOCK_SIZE_Y > KERNEL_SIZE_Y\n"
"sy_index = (sy_index + 1 <= KERNEL_SIZE_Y) ? sy_index + 1 : 1;\n"
"#else\n"
"sy_index++;\n"
"#endif\n"
"#endif\n"
"}\n"
"}\n"
, "c5e067caff80540a8477386273858801"};
ProgramSource filter2D_oclsrc(filter2D.programStr);
const struct ProgramEntry filterSepCol={"filterSepCol",
"#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n"
"#define RADIUS 1\n"
"#if CN ==1\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==2\n"
"#define ALIGN (((RADIUS)+1)>>1<<1)\n"
"#elif CN==3\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==4\n"
"#define ALIGN (RADIUS)\n"
"#define READ_TIMES_ROW ((2*(RADIUS+LSIZE0)-1)/LSIZE0)\n"
"#endif\n"
"#define DIG(a) a,\n"
"__constant float mat_kernel[] = { COEFF };\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void col_filter\n"
"(__global const GENTYPE_SRC * restrict src,\n"
"const int src_step_in_pixel,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"__global GENTYPE_DST * dst,\n"
"const int dst_offset_in_pixel,\n"
"const int dst_step_in_pixel,\n"
"const int dst_cols,\n"
"const int dst_rows)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_addr = mad24(y, src_step_in_pixel, x);\n"
"int end_addr = mad24(src_whole_rows - 1, src_step_in_pixel, src_whole_cols);\n"
"int i;\n"
"GENTYPE_SRC sum, temp[READ_TIMES_COL];\n"
"__local GENTYPE_SRC LDS_DAT[LSIZE1 * READ_TIMES_COL][LSIZE0 + 1];\n"
"for(i = 0;i<READ_TIMES_COL;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE1*src_step_in_pixel;\n"
"current_addr = current_addr < end_addr ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_COL;i++)\n"
"{\n"
"LDS_DAT[l_y+i*LSIZE1][l_x] = temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = LDS_DAT[l_y+RADIUSY][l_x]*mat_kernel[RADIUSY];\n"
"for(i=1;i<=RADIUSY;i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y+RADIUSY-i][l_x];\n"
"temp[1]=LDS_DAT[l_y+RADIUSY+i][l_x];\n"
"sum += temp[0] * mat_kernel[RADIUSY-i]+temp[1] * mat_kernel[RADIUSY+i];\n"
"}\n"
"if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"start_addr = mad24(y, dst_step_in_pixel, x + dst_offset_in_pixel);\n"
"dst[start_addr] = convert_to_DST(sum);\n"
"}\n"
"}\n"
, "1c383c110c1a2454f215d3327bf06165"};
ProgramSource filterSepCol_oclsrc(filterSepCol.programStr);
const struct ProgramEntry filterSepRow={"filterSepRow",
"#define READ_TIMES_ROW ((2*(RADIUSX+LSIZE0)-1)/LSIZE0)\n"
"#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n"
"#define RADIUS 1\n"
"#if CN ==1\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==2\n"
"#define ALIGN (((RADIUS)+1)>>1<<1)\n"
"#elif CN==3\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==4\n"
"#define ALIGN (RADIUS)\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#endif\n"
"#ifdef EXTRA_EXTRAPOLATION\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(t, minT, maxT) \\\n"
"{ \\\n"
"t = max(min(t, (maxT) - 1), (minT)); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, minT, maxT) \\\n"
"{ \\\n"
"if (t < (minT)) \\\n"
"t -= ((t - (maxT) + 1) / (maxT)) * (maxT); \\\n"
"if (t >= (maxT)) \\\n"
"t %= (maxT); \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(t, minT, maxT, delta) \\\n"
"{ \\\n"
"if ((maxT) - (minT) == 1) \\\n"
"t = (minT); \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (t < (minT)) \\\n"
"t = (minT) - (t - (minT)) - 1 + delta; \\\n"
"else \\\n"
"t = (maxT) - 1 - (t - (maxT)) - delta; \\\n"
"} \\\n"
"while (t >= (maxT) || t < (minT)); \\\n"
"\\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(t, minT, maxT) EXTRAPOLATE_(t, minT, maxT, 0)\n"
"#elif defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE(t, minT, maxT) EXTRAPOLATE_(t, minT, maxT, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#else\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#else\n"
"#define EXTRAPOLATE(t, minT, maxT) \\\n"
"{ \\\n"
"int _delta = t - (minT); \\\n"
"_delta = ADDR_L(_delta, 0, (maxT) - (minT)); \\\n"
"_delta = ADDR_R(_delta, (maxT) - (minT), _delta); \\\n"
"t = _delta + (minT); \\\n"
"}\n"
"#endif\n"
"#endif\n"
"#define DIG(a) a,\n"
"__constant float mat_kernel[] = { COEFF };\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D0\n"
"(__global uchar * restrict src,\n"
"int src_step_in_pixel,\n"
"int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows,\n"
"int src_whole_cols, int src_whole_rows,\n"
"__global float * dst,\n"
"int dst_step_in_pixel,\n"
"int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0)<<2;\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x - RADIUSX & 0xfffffffc;\n"
"int offset = src_offset_x - RADIUSX & 3;\n"
"int start_y = y + src_offset_y - radiusy;\n"
"int start_addr = mad24(start_y, src_step_in_pixel, start_x);\n"
"int i;\n"
"float4 sum;\n"
"uchar4 temp[READ_TIMES_ROW];\n"
"__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1, src_step_in_pixel, src_whole_cols);\n"
"for (i = 0; i < READ_TIMES_ROW; i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0*4;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = *(__global uchar4*)&src[current_addr];\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i].x = ELEM(start_x+i*LSIZE0*4,   src_offset_x, src_offset_x + src_cols, 0,         temp[i].x);\n"
"temp[i].y = ELEM(start_x+i*LSIZE0*4+1, src_offset_x, src_offset_x + src_cols, 0,         temp[i].y);\n"
"temp[i].z = ELEM(start_x+i*LSIZE0*4+2, src_offset_x, src_offset_x + src_cols, 0,         temp[i].z);\n"
"temp[i].w = ELEM(start_x+i*LSIZE0*4+3, src_offset_x, src_offset_x + src_cols, 0,         temp[i].w);\n"
"temp[i]   = ELEM(start_y,              src_offset_y, src_offset_y + src_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#else\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i].x = ELEM(start_x+i*LSIZE0*4,   0, src_whole_cols, 0,         temp[i].x);\n"
"temp[i].y = ELEM(start_x+i*LSIZE0*4+1, 0, src_whole_cols, 0,         temp[i].y);\n"
"temp[i].z = ELEM(start_x+i*LSIZE0*4+2, 0, src_whole_cols, 0,         temp[i].z);\n"
"temp[i].w = ELEM(start_x+i*LSIZE0*4+3, 0, src_whole_cols, 0,         temp[i].w);\n"
"temp[i]   = ELEM(start_y,              0, src_whole_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"#ifdef BORDER_ISOLATED\n"
"int not_all_in_range = (start_x<src_offset_x) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_offset_x + src_cols)| (start_y<src_offset_y) | (start_y >= src_offset_y + src_rows);\n"
"#else\n"
"int not_all_in_range = (start_x<0) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_whole_cols)| (start_y<0) | (start_y >= src_whole_rows);\n"
"#endif\n"
"int4 index[READ_TIMES_ROW];\n"
"int4 addr;\n"
"int s_y;\n"
"if (not_all_in_range)\n"
"{\n"
"for (i = 0; i < READ_TIMES_ROW; i++)\n"
"{\n"
"index[i] = (int4)(start_x+i*LSIZE0*4) + (int4)(0, 1, 2, 3);\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(index[i].x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].y, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].z, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].w, src_offset_x, src_offset_x + src_cols);\n"
"#else\n"
"EXTRAPOLATE(index[i].x, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].y, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].z, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].w, 0, src_whole_cols);\n"
"#endif\n"
"}\n"
"s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"addr = mad24((int4)s_y,(int4)src_step_in_pixel,index[i]);\n"
"temp[i].x = src[addr.x];\n"
"temp[i].y = src[addr.y];\n"
"temp[i].z = src[addr.z];\n"
"temp[i].w = src[addr.w];\n"
"}\n"
"}\n"
"else\n"
"{\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"temp[i] = *(__global uchar4*)&src[start_addr+i*LSIZE0*4];\n"
"}\n"
"#endif\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =convert_float4(vload4(0,(__local uchar*)&LDS_DAT[l_y][l_x]+RADIUSX+offset))*mat_kernel[RADIUSX];\n"
"for (i=1; i<=RADIUSX; i++)\n"
"{\n"
"temp[0] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset - i);\n"
"temp[1] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset + i);\n"
"sum += convert_float4(temp[0]) * mat_kernel[RADIUSX-i] + convert_float4(temp[1]) * mat_kernel[RADIUSX+i];\n"
"}\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"if ((x+3<dst_cols) & (y<dst_rows))\n"
"*(__global float4*)&dst[start_addr] = sum;\n"
"else if ((x+2<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"dst[start_addr+2] = sum.z;\n"
"}\n"
"else if ((x+1<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"}\n"
"else if (x<dst_cols && y<dst_rows)\n"
"dst[start_addr] = sum.x;\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D0\n"
"(__global uchar4 * restrict src,\n"
"int src_step_in_pixel,\n"
"int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows,\n"
"int src_whole_cols, int src_whole_rows,\n"
"__global float4 * dst,\n"
"int dst_step_in_pixel,\n"
"int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float4 sum;\n"
"uchar4 temp[READ_TIMES_ROW];\n"
"__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, src_offset_x, src_offset_x + src_cols, (uchar4)0, temp[i]);\n"
"temp[i]= ELEM(start_y,          src_offset_y, src_offset_y + src_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#else\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, 0, src_whole_cols, (uchar4)0, temp[i]);\n"
"temp[i]= ELEM(start_y,          0, src_whole_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"s_x = start_x+i*LSIZE0;\n"
"s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_x, 0, src_whole_cols);\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"index[i]=mad24(s_y, src_step_in_pixel, s_x);\n"
"}\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"temp[i] = src[index[i]];\n"
"#endif\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =convert_float4(LDS_DAT[l_y][l_x+RADIUSX])*mat_kernel[RADIUSX];\n"
"for (i=1; i<=RADIUSX; i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += convert_float4(temp[0])*mat_kernel[RADIUSX-i]+convert_float4(temp[1])*mat_kernel[RADIUSX+i];\n"
"}\n"
"if (x<dst_cols && y<dst_rows)\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D5\n"
"(__global float * restrict src,\n"
"int src_step_in_pixel,\n"
"int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows,\n"
"int src_whole_cols, int src_whole_rows,\n"
"__global float * dst,\n"
"int dst_step_in_pixel,\n"
"int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float sum;\n"
"float temp[READ_TIMES_ROW];\n"
"__local float LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, src_offset_x, src_offset_x + src_cols, (float)0,temp[i]);\n"
"temp[i]= ELEM(start_y,          src_offset_y, src_offset_y + src_rows, (float)0,temp[i]);\n"
"}\n"
"#else\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, 0, src_whole_cols, (float)0,temp[i]);\n"
"temp[i]= ELEM(start_y,          0, src_whole_rows, (float)0,temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"s_x = start_x + i*LSIZE0, s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_x, 0, src_whole_cols);\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"index[i]=mad24(s_y, src_step_in_pixel, s_x);\n"
"}\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"temp[i] = src[index[i]];\n"
"#endif\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\n"
"for (i=1; i<=RADIUSX; i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n"
"}\n"
"if (x<dst_cols && y<dst_rows)\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D5\n"
"(__global float4 * restrict src,\n"
"int src_step_in_pixel,\n"
"int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows,\n"
"int src_whole_cols, int src_whole_rows,\n"
"__global float4 * dst,\n"
"int dst_step_in_pixel,\n"
"int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float4 sum;\n"
"float4 temp[READ_TIMES_ROW];\n"
"__local float4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, src_offset_x, src_offset_x + src_cols, (float4)0,temp[i]);\n"
"temp[i]= ELEM(start_y,          src_offset_y, src_offset_y + src_rows, (float4)0,temp[i]);\n"
"}\n"
"#else\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0, 0, src_whole_cols, (float4)0,temp[i]);\n"
"temp[i]= ELEM(start_y,          0, src_whole_rows, (float4)0,temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"{\n"
"s_x = start_x + i*LSIZE0, s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_x, 0, src_whole_cols);\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"index[i]=mad24(s_y,src_step_in_pixel,s_x);\n"
"}\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"temp[i] = src[index[i]];\n"
"#endif\n"
"for (i = 0; i<READ_TIMES_ROW; i++)\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\n"
"for (i=1; i<=RADIUSX; i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n"
"}\n"
"if (x<dst_cols && y<dst_rows)\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
, "fb6e2e1259589b188ad0d79a0844481a"};
ProgramSource filterSepRow_oclsrc(filterSepRow.programStr);
const struct ProgramEntry gftt={"gftt",
"__kernel void findCorners(__global const uchar * eigptr, int eig_step, int eig_offset,\n"
"#ifdef HAVE_MASK\n"
"__global const uchar * mask, int mask_step, int mask_offset,\n"
"#endif\n"
"__global const uchar * tmpptr, int tmp_step, int tmp_offset,\n"
"__global uchar * cornersptr, __global int * counter,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"++x, ++y;\n"
"int eig_index = mad24(y, eig_step, eig_offset + x * (int)sizeof(float));\n"
"int tmp_index = mad24(y, tmp_step, tmp_offset + x * (int)sizeof(float));\n"
"#ifdef HAVE_MASK\n"
"int mask_index = mad24(y, mask_step, mask_offset + x);\n"
"mask += mask_index;\n"
"#endif\n"
"float val = *(__global const float *)(eigptr + eig_index);\n"
"float tmp = *(__global const float *)(tmpptr + tmp_index);\n"
"if (val != 0 && val == tmp\n"
"#ifdef HAVE_MASK\n"
"&& mask[0] != 0\n"
"#endif\n"
")\n"
"{\n"
"__global float2 * corners = (__global float2 *)(cornersptr + (int)sizeof(float2) * atomic_inc(counter));\n"
"corners[0] = (float2)(val, as_float( (x<<16) | y ));\n"
"}\n"
"}\n"
"}\n"
, "66d527567333d2da9176bdef1a01d6c0"};
ProgramSource gftt_oclsrc(gftt.programStr);
const struct ProgramEntry histogram={"histogram",
"__kernel void calculate_histogram(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * hist, int total)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int id = get_global_id(0);\n"
"int gid = get_group_id(0);\n"
"__local int localhist[BINS];\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"localhist[i] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int grain = HISTS_COUNT * WGS; id < total; id += grain)\n"
"{\n"
"int src_index = mad24(id / src_cols, src_step, src_offset + id % src_cols);\n"
"atomic_inc(localhist + (int)src[src_index]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"*(__global int *)(hist + mad24(gid, BINS * (int)sizeof(int), i * (int)sizeof(int))) = localhist[i];\n"
"}\n"
"__kernel void merge_histogram(__global const int * ghist, __global int * hist)\n"
"{\n"
"int lid = get_local_id(0);\n"
"#pragma unroll\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"hist[i] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#pragma unroll\n"
"for (int i = 0; i < HISTS_COUNT; ++i)\n"
"{\n"
"#pragma unroll\n"
"for (int j = lid; j < BINS; j += WGS)\n"
"hist[j] += ghist[mad24(i, BINS, j)];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"__kernel void calcLUT(__global uchar * dst, __constant int * hist, int total)\n"
"{\n"
"int lid = get_local_id(0);\n"
"__local int sumhist[BINS];\n"
"__local float scale;\n"
"sumhist[lid] = hist[lid];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lid == 0)\n"
"{\n"
"int sum = 0, i = 0;\n"
"while (!sumhist[i])\n"
"++i;\n"
"if (total == sumhist[i])\n"
"{\n"
"scale = 1;\n"
"for (int j = 0; j < BINS; ++j)\n"
"sumhist[i] = i;\n"
"}\n"
"else\n"
"{\n"
"scale = 255.f / (total - sumhist[i]);\n"
"for (sumhist[i++] = 0; i < BINS; i++)\n"
"{\n"
"sum += sumhist[i];\n"
"sumhist[i] = sum;\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#pragma unroll\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"dst[i]= convert_uchar_sat_rte(convert_float(sumhist[i]) * scale);\n"
"}\n"
, "e165f17b5ef10a6d8fddc0626cb664b9"};
ProgramSource histogram_oclsrc(histogram.programStr);
const struct ProgramEntry integral_sqrsum={"integral_sqrsum",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if sqdepth == 6\n"
"#define CONVERT(step) ((step)>>1)\n"
"#else\n"
"#define CONVERT(step) ((step))\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"#define noconvert\n"
"#if sdepth == 4\n"
"kernel void integral_cols(__global uchar4 *src, __global int *sum, __global TYPE *sqsum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step, int dst1_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"TYPE4 sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"__local TYPE* sqsum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : 0);\n"
"sum_t[0] = (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] = (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = convert_TYPE4(src_t[0] * src_t[0]);\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = convert_TYPE4(src_t[1] * src_t[1]);\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int loc_s0 = gid * dst_step  + i + lid - 1 - pre_invalid * dst_step /4, loc_s1 = loc_s0 + dst_step ;\n"
"int loc_sq0 = gid * CONVERT(dst1_step) + i + lid - 1 - pre_invalid * dst1_step / sizeof(TYPE),loc_sq1 = loc_sq0 + CONVERT(dst1_step);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_rows(__global int4 *srcsum, __global TYPE4 * srcsqsum,__global int *sum,\n"
"__global TYPE *sqsum, int rows, int cols, int src_step, int src1_step, int sum_step,\n"
"int sqsum_step, int sum_offset, int sqsum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"TYPE4 sqsrc_t[2],sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"__local TYPE *sqsum_p;\n"
"src_step = src_step >> 4;\n"
"src1_step = (src1_step / sizeof(TYPE)) >> 2 ;\n"
"gid <<= 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid ] : (int4)0;\n"
"sqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid ] : (TYPE4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid  + 1] : (int4)0;\n"
"sqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid  + 1] : (TYPE4)0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] =  (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = sqsrc_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = sqsrc_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"sqsum[sqsum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid  * sum_step;\n"
"int loc1 = gid  * CONVERT(sqsum_step);\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 4 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"sqsum[sqsum_offset + loc1 + k * sqsum_step / sizeof(TYPE)] = 0;\n"
"}\n"
"}\n"
"int loc_s0 = sum_offset + gid  * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"int loc_sq0 = sqsum_offset + gid  * CONVERT(sqsum_step) + sqsum_step / sizeof(TYPE) + i + lid, loc_sq1 = loc_sq0 + CONVERT(sqsum_step) ;\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#elif sdepth == 5\n"
"kernel void integral_cols(__global uchar4 *src, __global float *sum, __global TYPE *sqsum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step, int dst1_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"TYPE4 sqsum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local float* sum_p;\n"
"__local TYPE* sqsum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : (float4)0);\n"
"src_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : (float4)0);\n"
"sum_t[0] = (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] = (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = convert_TYPE4(src_t[0] * src_t[0]);\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = convert_TYPE4(src_t[1] * src_t[1]);\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"int loc_sq0 = gid * CONVERT(dst1_step) + i + lid - 1 - pre_invalid * dst1_step / sizeof(TYPE), loc_sq1 = loc_sq0 + CONVERT(dst1_step);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_rows(__global float4 *srcsum, __global TYPE4 * srcsqsum, __global float *sum ,\n"
"__global TYPE *sqsum, int rows, int cols, int src_step, int src1_step, int sum_step,\n"
"int sqsum_step, int sum_offset, int sqsum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"TYPE4 sqsrc_t[2],sqsum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local float *sum_p;\n"
"__local TYPE *sqsum_p;\n"
"src_step = src_step >> 4;\n"
"src1_step = (src1_step / sizeof(TYPE)) >> 2;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\n"
"sqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid * 2] : (TYPE4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\n"
"sqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid * 2 + 1] : (TYPE4)0;\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] =  (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = sqsrc_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = sqsrc_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"sqsum[sqsum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"int loc1 = gid * 2 * CONVERT(sqsum_step);\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"sqsum[sqsum_offset + loc1 + k * sqsum_step / sizeof(TYPE)] = 0;\n"
"}\n"
"}\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"int loc_sq0 = sqsum_offset + gid * 2 * CONVERT(sqsum_step) + sqsum_step / sizeof(TYPE) + i + lid, loc_sq1 = loc_sq0 + CONVERT(sqsum_step) ;\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#endif\n"
, "584d5cd32272585a35804b7891b06893"};
ProgramSource integral_sqrsum_oclsrc(integral_sqrsum.programStr);
const struct ProgramEntry integral_sum={"integral_sum",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"#if sdepth == 4\n"
"kernel void integral_sum_cols(__global uchar4 *src, __global int *sum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid + 1]) : 0);\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_sum_rows(__global int4 *srcsum, __global int *sum,\n"
"int rows, int cols, int src_step, int sum_step, int sum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : 0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : 0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"}\n"
"}\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#elif sdepth == 5\n"
"kernel void integral_sum_cols(__global uchar4 *src, __global float *sum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float* sum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid]) : (float4)0);\n"
"src_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid + 1]) : (float4)0);\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_sum_rows(__global float4 *srcsum, __global float *sum,\n"
"int rows, int cols, int src_step, int sum_step, int sum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float *sum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"}\n"
"}\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#endif\n"
, "982fe063570bb84a5d4d82a633951813"};
ProgramSource integral_sum_oclsrc(integral_sum.programStr);
const struct ProgramEntry match_template={"match_template",
"#define DATA_SIZE ((int)sizeof(type))\n"
"#define ELEM_TYPE elem_type\n"
"#define ELEM_SIZE ((int)sizeof(elem_type))\n"
"#define CN cn\n"
"#define SQSUMS_PTR(ox, oy) mad24(gidy + oy, img_sqsums_step, gidx*CN + img_sqsums_offset + ox*CN)\n"
"#define SUMS_PTR(ox, oy) mad24(gidy + oy, img_sums_step,   gidx*CN + img_sums_offset + ox*CN)\n"
"inline float normAcc(float num, float denum)\n"
"{\n"
"if(fabs(num) < denum)\n"
"{\n"
"return num / denum;\n"
"}\n"
"if(fabs(num) < denum * 1.125f)\n"
"{\n"
"return num > 0 ? 1 : -1;\n"
"}\n"
"return 0;\n"
"}\n"
"inline float normAcc_SQDIFF(float num, float denum)\n"
"{\n"
"if(fabs(num) < denum)\n"
"{\n"
"return num / denum;\n"
"}\n"
"if(fabs(num) < denum * 1.125f)\n"
"{\n"
"return num > 0 ? 1 : -1;\n"
"}\n"
"return 1;\n"
"}\n"
"__kernel void matchTemplate_Naive_CCORR (__global const uchar * img,int img_step,int img_offset,\n"
"__global const uchar * tpl,int tpl_step,int tpl_offset,int tpl_rows, int tpl_cols,\n"
"__global uchar * res,int res_step,int res_offset,int res_rows,int res_cols)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float sum = 0;\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const ELEM_TYPE * img_ptr = (__global const ELEM_TYPE *)(img + mad24(gidy + i, img_step, gidx*DATA_SIZE + img_offset));\n"
"__global const ELEM_TYPE * tpl_ptr = (__global const ELEM_TYPE *)(tpl + mad24(i, tpl_step, tpl_offset));\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"#pragma unroll\n"
"for (int c = 0; c < CN; c++)\n"
"sum += (float)(img_ptr[j*CN+c] * tpl_ptr[j*CN+c]);\n"
"}\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = sum;\n"
"}\n"
"}\n"
"__kernel void matchTemplate_CCORR_NORMED ( __global const uchar * img_sqsums, int img_sqsums_step, int img_sqsums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int tpl_rows, int tpl_cols, float tpl_sqsum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sqsums_step /= sizeof(float);\n"
"img_sqsums_offset /= sizeof(float);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global float * sqsum = (__global float*)(img_sqsums);\n"
"float image_sqsum_ = (float)(\n"
"(sqsum[SQSUMS_PTR(tpl_cols, tpl_rows)] - sqsum[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(sqsum[SQSUMS_PTR(0, tpl_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = normAcc(*result, sqrt(image_sqsum_ * tpl_sqsum));\n"
"}\n"
"}\n"
"__kernel void matchTemplate_Naive_SQDIFF(__global const uchar * img,int img_step,int img_offset,\n"
"__global const uchar * tpl,int tpl_step,int tpl_offset,int tpl_rows, int tpl_cols,\n"
"__global uchar * res,int res_step,int res_offset,int res_rows,int res_cols)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float delta;\n"
"float sum = 0;\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const ELEM_TYPE * img_ptr = (__global const ELEM_TYPE *)(img + mad24(gidy + i, img_step, gidx*DATA_SIZE + img_offset));\n"
"__global const ELEM_TYPE * tpl_ptr = (__global const ELEM_TYPE *)(tpl + mad24(i, tpl_step, tpl_offset));\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"#pragma unroll\n"
"for (int c = 0; c < CN; c++)\n"
"{\n"
"delta = (float)(img_ptr[j*CN+c] - tpl_ptr[j*CN+c]);\n"
"sum += delta*delta;\n"
"}\n"
"}\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = sum;\n"
"}\n"
"}\n"
"__kernel void matchTemplate_SQDIFF_NORMED ( __global const uchar * img_sqsums, int img_sqsums_step, int img_sqsums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int tpl_rows, int tpl_cols, float tpl_sqsum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sqsums_step /= sizeof(float);\n"
"img_sqsums_offset /= sizeof(float);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global float * sqsum = (__global float*)(img_sqsums);\n"
"float image_sqsum_ = (float)(\n"
"(sqsum[SQSUMS_PTR(tpl_cols, tpl_rows)] - sqsum[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(sqsum[SQSUMS_PTR(0, tpl_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = normAcc_SQDIFF(image_sqsum_ - 2.f * result[0] + tpl_sqsum, sqrt(image_sqsum_ * tpl_sqsum));\n"
"}\n"
"}\n"
"__kernel void matchTemplate_Prepared_CCOEFF_C1 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int tpl_rows, int tpl_cols, float tpl_sum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_step /= ELEM_SIZE;\n"
"img_sums_offset /= ELEM_SIZE;\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"float image_sum_ = 0;\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"image_sum_ += (float)((sum[SUMS_PTR(tpl_cols, tpl_rows)] - sum[SUMS_PTR(tpl_cols, 0)])-\n"
"(sum[SUMS_PTR(0, tpl_rows)] - sum[SUMS_PTR(0, 0)])) * tpl_sum;\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result -= image_sum_;\n"
"}\n"
"}\n"
"__kernel void matchTemplate_Prepared_CCOEFF_C2 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int tpl_rows, int tpl_cols, float tpl_sum_0,float tpl_sum_1)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_step /= ELEM_SIZE;\n"
"img_sums_offset /= ELEM_SIZE;\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"float image_sum_ = 0;\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"image_sum_ += tpl_sum_0 * (float)((sum[SUMS_PTR(tpl_cols, tpl_rows)] - sum[SUMS_PTR(tpl_cols, 0)])    -(sum[SUMS_PTR(0, tpl_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"image_sum_ += tpl_sum_1 * (float)((sum[SUMS_PTR(tpl_cols, tpl_rows)+1] - sum[SUMS_PTR(tpl_cols, 0)+1])-(sum[SUMS_PTR(0, tpl_rows)+1] - sum[SUMS_PTR(0, 0)+1]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result -= image_sum_;\n"
"}\n"
"}\n"
"__kernel void matchTemplate_Prepared_CCOEFF_C4 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int tpl_rows, int tpl_cols, float tpl_sum_0,float tpl_sum_1,float tpl_sum_2,float tpl_sum_3)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_step /= ELEM_SIZE;\n"
"img_sums_offset /= ELEM_SIZE;\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"float image_sum_ = 0;\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"int c_r = SUMS_PTR(tpl_cols, tpl_rows);\n"
"int c_o = SUMS_PTR(tpl_cols, 0);\n"
"int o_r = SUMS_PTR(0,tpl_rows);\n"
"int oo = SUMS_PTR(0, 0);\n"
"image_sum_ += tpl_sum_0 * (float)((sum[c_r]   - sum[c_o])  -(sum[o_r]   - sum[oo]));\n"
"image_sum_ += tpl_sum_1 * (float)((sum[c_r+1] - sum[c_o+1])-(sum[o_r+1] - sum[oo+1]));\n"
"image_sum_ += tpl_sum_2 * (float)((sum[c_r+2] - sum[c_o+2])-(sum[o_r+2] - sum[oo+2]));\n"
"image_sum_ += tpl_sum_3 * (float)((sum[c_r+3] - sum[c_o+3])-(sum[o_r+3] - sum[oo+3]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result -= image_sum_;\n"
"}\n"
"}\n"
"__kernel void matchTemplate_CCOEFF_NORMED_C1 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global const uchar * img_sqsums, int img_sqsums_step, int img_sqsums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int t_rows, int t_cols, float weight, float tpl_sum, float tpl_sqsum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_offset   /= ELEM_SIZE;\n"
"img_sums_step     /= ELEM_SIZE;\n"
"img_sqsums_step   /= sizeof(float);\n"
"img_sqsums_offset /= sizeof(float);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"__global float * sqsum = (__global float*)(img_sqsums);\n"
"float image_sum_ =  (float)((sum[SUMS_PTR(t_cols, t_rows)] - sum[SUMS_PTR(t_cols, 0)]) -\n"
"(sum[SUMS_PTR(0, t_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"float image_sqsum_ = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)] - sqsum[SQSUMS_PTR(t_cols, 0)]) -\n"
"(sqsum[SQSUMS_PTR(0, t_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = normAcc((*result) - image_sum_ * tpl_sum,\n"
"sqrt(tpl_sqsum * (image_sqsum_ - weight * image_sum_ * image_sum_)));\n"
"}\n"
"}\n"
"__kernel void matchTemplate_CCOEFF_NORMED_C2 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global const uchar * img_sqsums, int img_sqsums_step, int img_sqsums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int t_rows, int t_cols, float weight, float tpl_sum_0, float tpl_sum_1, float tpl_sqsum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_offset   /= ELEM_SIZE;\n"
"img_sums_step     /= ELEM_SIZE;\n"
"img_sqsums_step   /= sizeof(float);\n"
"img_sqsums_offset /= sizeof(float);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"float sum_[2];\n"
"float sqsum_[2];\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"__global float * sqsum = (__global float*)(img_sqsums);\n"
"sum_[0] =  (float)((sum[SUMS_PTR(t_cols, t_rows)] - sum[SUMS_PTR(t_cols, 0)])-(sum[SUMS_PTR(0, t_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"sum_[1] =  (float)((sum[SUMS_PTR(t_cols, t_rows)+1] - sum[SUMS_PTR(t_cols, 0)+1])-(sum[SUMS_PTR(0, t_rows)+1] - sum[SUMS_PTR(0, 0)+1]));\n"
"sqsum_[0] = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)] - sqsum[SQSUMS_PTR(t_cols, 0)])-(sqsum[SQSUMS_PTR(0, t_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"sqsum_[1] = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)+1] - sqsum[SQSUMS_PTR(t_cols, 0)+1])-(sqsum[SQSUMS_PTR(0, t_rows)+1] - sqsum[SQSUMS_PTR(0, 0)+1]));\n"
"float num = sum_[0]*tpl_sum_0 + sum_[1]*tpl_sum_1;\n"
"float denum = sqrt( tpl_sqsum * (sqsum_[0] - weight * sum_[0]* sum_[0] +\n"
"sqsum_[1] - weight * sum_[1]* sum_[1]));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = normAcc((*result) - num, denum);\n"
"}\n"
"}\n"
"__kernel void matchTemplate_CCOEFF_NORMED_C4 (__global const uchar * img_sums, int img_sums_step, int img_sums_offset,\n"
"__global const uchar * img_sqsums, int img_sqsums_step, int img_sqsums_offset,\n"
"__global uchar * res, int res_step, int res_offset, int res_rows, int res_cols,\n"
"int t_rows, int t_cols, float weight,\n"
"float tpl_sum_0,float tpl_sum_1,float tpl_sum_2,float tpl_sum_3,\n"
"float tpl_sqsum)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_offset   /= ELEM_SIZE;\n"
"img_sums_step     /= ELEM_SIZE;\n"
"img_sqsums_step   /= sizeof(float);\n"
"img_sqsums_offset /= sizeof(float);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx * (int)sizeof(float));\n"
"float sum_[4];\n"
"float sqsum_[4];\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(img_sums);\n"
"__global float * sqsum = (__global float*)(img_sqsums);\n"
"int c_r = SUMS_PTR(t_cols, t_rows);\n"
"int c_o = SUMS_PTR(t_cols, 0);\n"
"int o_r = SUMS_PTR(0, t_rows);\n"
"int o_o = SUMS_PTR(0, 0);\n"
"sum_[0] =  (float)((sum[c_r]   - sum[c_o])  -(sum[o_r]   - sum[o_o ]));\n"
"sum_[1] =  (float)((sum[c_r+1] - sum[c_o+1])-(sum[o_r+1] - sum[o_o +1]));\n"
"sum_[2] =  (float)((sum[c_r+2] - sum[c_o+2])-(sum[o_r+2] - sum[o_o +2]));\n"
"sum_[3] =  (float)((sum[c_r+3] - sum[c_o+3])-(sum[o_r+3] - sum[o_o +3]));\n"
"c_r = SQSUMS_PTR(t_cols, t_rows);\n"
"c_o = SQSUMS_PTR(t_cols, 0);\n"
"o_r = SQSUMS_PTR(0, t_rows);\n"
"o_o = SQSUMS_PTR(0, 0);\n"
"sqsum_[0] = (float)((sqsum[c_r]   - sqsum[c_o])  -(sqsum[o_r]   - sqsum[o_o]));\n"
"sqsum_[1] = (float)((sqsum[c_r+1] - sqsum[c_o+1])-(sqsum[o_r+1] - sqsum[o_o+1]));\n"
"sqsum_[2] = (float)((sqsum[c_r+2] - sqsum[c_o+2])-(sqsum[o_r+2] - sqsum[o_o+2]));\n"
"sqsum_[3] = (float)((sqsum[c_r+3] - sqsum[c_o+3])-(sqsum[o_r+3] - sqsum[o_o+3]));\n"
"float num = sum_[0]*tpl_sum_0 + sum_[1]*tpl_sum_1 + sum_[2]*tpl_sum_2 + sum_[3]*tpl_sum_3;\n"
"float denum = sqrt( tpl_sqsum * (\n"
"sqsum_[0] - weight * sum_[0]* sum_[0] +\n"
"sqsum_[1] - weight * sum_[1]* sum_[1] +\n"
"sqsum_[2] - weight * sum_[2]* sum_[2] +\n"
"sqsum_[3] - weight * sum_[3]* sum_[3] ));\n"
"__global float * result = (__global float *)(res+res_idx);\n"
"*result = normAcc((*result) - num, denum);\n"
"}\n"
"}\n"
, "8982d5ad8a6bf5d0d19a29f3a6ed350a"};
ProgramSource match_template_oclsrc(match_template.programStr);
const struct ProgramEntry medianFilter={"medianFilter",
"#define DATA_TYPE type\n"
"#define scnbytes ((int)sizeof(type))\n"
"#define op(a,b) {    mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter3(__global const uchar* srcptr, int srcStep, int srcOffset,\n"
"__global uchar* dstptr, int dstStep, int dstOffset,\n"
"int rows, int cols)\n"
"{\n"
"__local DATA_TYPE data[18][18];\n"
"int x = get_local_id(0);\n"
"int y = get_local_id(1);\n"
"int gx= get_global_id(0);\n"
"int gy= get_global_id(1);\n"
"int dx = gx - x - 1;\n"
"int dy = gy - y - 1;\n"
"const int id = min((int)(x*16+y), 9*18-1);\n"
"int dr = id / 18;\n"
"int dc = id % 18;\n"
"int c = clamp(dx+dc, 0, cols-1);\n"
"int r = clamp(dy+dr, 0, rows-1);\n"
"int index1 = mad24(r, srcStep, srcOffset + c*scnbytes);\n"
"r = clamp(dy+dr+9, 0, rows-1);\n"
"int index9 = mad24(r, srcStep, srcOffset + c*scnbytes);\n"
"__global DATA_TYPE * src = (__global DATA_TYPE *)(srcptr + index1);\n"
"data[dr][dc] = src[0];\n"
"src = (__global DATA_TYPE *)(srcptr + index9);\n"
"data[dr+9][dc] = src[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"DATA_TYPE p0=data[y][x], p1=data[y][(x+1)], p2=data[y][(x+2)];\n"
"DATA_TYPE p3=data[y+1][x], p4=data[y+1][(x+1)], p5=data[y+1][(x+2)];\n"
"DATA_TYPE p6=data[y+2][x], p7=data[y+2][(x+1)], p8=data[y+2][(x+2)];\n"
"DATA_TYPE mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"int dst_index = mad24( gy, dstStep, dstOffset + gx * scnbytes);\n"
"if( gy < rows && gx < cols)\n"
"{\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE *)(dstptr + dst_index);\n"
"dst[0] = p4;\n"
"}\n"
"}\n"
"__kernel void medianFilter5(__global const uchar* srcptr, int srcStep, int srcOffset,\n"
"__global uchar* dstptr, int dstStep, int dstOffset,\n"
"int rows, int cols)\n"
"{\n"
"__local DATA_TYPE data[20][20];\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"int gx=get_global_id(0);\n"
"int gy=get_global_id(1);\n"
"int dx = gx - x - 2;\n"
"int dy = gy - y - 2;\n"
"const int id = min((int)(x*16+y), 10*20-1);\n"
"int dr=id/20;\n"
"int dc=id%20;\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"int r = clamp(dy+dr, 0, rows-1);\n"
"int index1 = mad24(r, srcStep, srcOffset + c*scnbytes);\n"
"r = clamp(dy+dr+10, 0, rows-1);\n"
"int index10 = mad24(r, srcStep, srcOffset + c*scnbytes);\n"
"__global DATA_TYPE * src = (__global DATA_TYPE *)(srcptr + index1);\n"
"data[dr][dc] = src[0];\n"
"src = (__global DATA_TYPE *)(srcptr + index10);\n"
"data[dr+10][dc] = src[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"DATA_TYPE p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\n"
"DATA_TYPE p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\n"
"DATA_TYPE p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\n"
"DATA_TYPE p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\n"
"DATA_TYPE p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\n"
"DATA_TYPE mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"int dst_index = mad24( gy, dstStep, dstOffset + gx * scnbytes);\n"
"if( gy < rows && gx < cols)\n"
"{\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE *)(dstptr + dst_index);\n"
"dst[0] = p12;\n"
"}\n"
"}\n"
, "a0762c9f0dc54fc5dc7a2a639b2c0c99"};
ProgramSource medianFilter_oclsrc(medianFilter.programStr);
const struct ProgramEntry moments={"moments",
"#if TILE_SIZE != 32\n"
"#error \"TILE SIZE should be 32\"\n"
"#endif\n"
"__kernel void moments(__global const uchar* src, int src_step, int src_offset,\n"
"int src_rows, int src_cols, __global int* mom0, int xtiles)\n"
"{\n"
"int x0 = get_global_id(0);\n"
"int y0 = get_group_id(1);\n"
"int x, y = get_local_id(1);\n"
"int x_min = x0*TILE_SIZE;\n"
"int ypix = y0*TILE_SIZE + y;\n"
"__local int mom[TILE_SIZE][10];\n"
"if( x_min < src_cols && y0*TILE_SIZE < src_rows )\n"
"{\n"
"if( ypix < src_rows )\n"
"{\n"
"int x_max = min(src_cols - x_min, TILE_SIZE);\n"
"__global const uchar* ptr = src + src_offset + ypix*src_step + x_min;\n"
"int4 S = (int4)(0,0,0,0), p;\n"
"#define SUM_ELEM(elem, ofs) \\\n"
"(int4)(1, (ofs), (ofs)*(ofs), (ofs)*(ofs)*(ofs))*elem\n"
"x = x_max & -4;\n"
"if( x_max >= 4 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr));\n"
"S += SUM_ELEM(p.s0, 0) + SUM_ELEM(p.s1, 1) + SUM_ELEM(p.s2, 2) + SUM_ELEM(p.s3, 3);\n"
"if( x_max >= 8 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+4));\n"
"S += SUM_ELEM(p.s0, 4) + SUM_ELEM(p.s1, 5) + SUM_ELEM(p.s2, 6) + SUM_ELEM(p.s3, 7);\n"
"if( x_max >= 12 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+8));\n"
"S += SUM_ELEM(p.s0, 8) + SUM_ELEM(p.s1, 9) + SUM_ELEM(p.s2, 10) + SUM_ELEM(p.s3, 11);\n"
"if( x_max >= 16 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+12));\n"
"S += SUM_ELEM(p.s0, 12) + SUM_ELEM(p.s1, 13) + SUM_ELEM(p.s2, 14) + SUM_ELEM(p.s3, 15);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"if( x_max >= 20 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+16));\n"
"S += SUM_ELEM(p.s0, 16) + SUM_ELEM(p.s1, 17) + SUM_ELEM(p.s2, 18) + SUM_ELEM(p.s3, 19);\n"
"if( x_max >= 24 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+20));\n"
"S += SUM_ELEM(p.s0, 20) + SUM_ELEM(p.s1, 21) + SUM_ELEM(p.s2, 22) + SUM_ELEM(p.s3, 23);\n"
"if( x_max >= 28 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+24));\n"
"S += SUM_ELEM(p.s0, 24) + SUM_ELEM(p.s1, 25) + SUM_ELEM(p.s2, 26) + SUM_ELEM(p.s3, 27);\n"
"if( x_max >= 32 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+28));\n"
"S += SUM_ELEM(p.s0, 28) + SUM_ELEM(p.s1, 29) + SUM_ELEM(p.s2, 30) + SUM_ELEM(p.s3, 31);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"if( x < x_max )\n"
"{\n"
"int ps = ptr[x];\n"
"S += SUM_ELEM(ps, x);\n"
"if( x+1 < x_max )\n"
"{\n"
"ps = ptr[x+1];\n"
"S += SUM_ELEM(ps, x+1);\n"
"if( x+2 < x_max )\n"
"{\n"
"ps = ptr[x+2];\n"
"S += SUM_ELEM(ps, x+2);\n"
"}\n"
"}\n"
"}\n"
"int sy = y*y;\n"
"mom[y][0] = S.s0;\n"
"mom[y][1] = S.s1;\n"
"mom[y][2] = y*S.s0;\n"
"mom[y][3] = S.s2;\n"
"mom[y][4] = y*S.s1;\n"
"mom[y][5] = sy*S.s0;\n"
"mom[y][6] = S.s3;\n"
"mom[y][7] = y*S.s2;\n"
"mom[y][8] = sy*S.s1;\n"
"mom[y][9] = y*sy*S.s0;\n"
"}\n"
"else\n"
"mom[y][0] = mom[y][1] = mom[y][2] = mom[y][3] = mom[y][4] =\n"
"mom[y][5] = mom[y][6] = mom[y][7] = mom[y][8] = mom[y][9] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#define REDUCE(d) \\\n"
"if( y < d ) \\\n"
"{ \\\n"
"mom[y][0] += mom[y+d][0]; \\\n"
"mom[y][1] += mom[y+d][1]; \\\n"
"mom[y][2] += mom[y+d][2]; \\\n"
"mom[y][3] += mom[y+d][3]; \\\n"
"mom[y][4] += mom[y+d][4]; \\\n"
"mom[y][5] += mom[y+d][5]; \\\n"
"mom[y][6] += mom[y+d][6]; \\\n"
"mom[y][7] += mom[y+d][7]; \\\n"
"mom[y][8] += mom[y+d][8]; \\\n"
"mom[y][9] += mom[y+d][9]; \\\n"
"} \\\n"
"barrier(CLK_LOCAL_MEM_FENCE)\n"
"REDUCE(16);\n"
"REDUCE(8);\n"
"REDUCE(4);\n"
"REDUCE(2);\n"
"if( y == 0 )\n"
"{\n"
"__global int* momout = mom0 + (y0*xtiles + x0)*10;\n"
"momout[0] = mom[0][0] + mom[1][0];\n"
"momout[1] = mom[0][1] + mom[1][1];\n"
"momout[2] = mom[0][2] + mom[1][2];\n"
"momout[3] = mom[0][3] + mom[1][3];\n"
"momout[4] = mom[0][4] + mom[1][4];\n"
"momout[5] = mom[0][5] + mom[1][5];\n"
"momout[6] = mom[0][6] + mom[1][6];\n"
"momout[7] = mom[0][7] + mom[1][7];\n"
"momout[8] = mom[0][8] + mom[1][8];\n"
"momout[9] = mom[0][9] + mom[1][9];\n"
"}\n"
"}\n"
"}\n"
, "be1de12b5a5f3107088ae3f80818d51b"};
ProgramSource moments_oclsrc(moments.programStr);
const struct ProgramEntry morph={"morph",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"#ifdef ERODE\n"
"#define VAL 255\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL 0\n"
"#endif\n"
"#endif\n"
"#ifdef DEPTH_5\n"
"#ifdef ERODE\n"
"#define VAL FLT_MAX\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL -FLT_MAX\n"
"#endif\n"
"#endif\n"
"#ifdef DEPTH_6\n"
"#ifdef ERODE\n"
"#define VAL DBL_MAX\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL -DBL_MAX\n"
"#endif\n"
"#endif\n"
"#ifdef ERODE\n"
"#define MORPH_OP(A,B) min((A),(B))\n"
"#endif\n"
"#ifdef DILATE\n"
"#define MORPH_OP(A,B) max((A),(B))\n"
"#endif\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"__kernel void morph(__global const uchar * restrict srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int src_offset_x, int src_offset_y,\n"
"int cols, int rows,\n"
"__constant uchar * mat_kernel,\n"
"int src_whole_cols, int src_whole_rows)\n"
"{\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int x = get_group_id(0)*LSIZE0;\n"
"int y = get_group_id(1)*LSIZE1;\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int end_x = x + src_offset_x+LSIZE0+RADIUSX;\n"
"int width = end_x -(x+src_offset_x-RADIUSX)+1;\n"
"int start_y = y+src_offset_y-RADIUSY;\n"
"int point1 = mad24(l_y,LSIZE0,l_x);\n"
"int point2 = point1 + LSIZE0*LSIZE1;\n"
"int tl_x = point1 % width;\n"
"int tl_y = point1 / width;\n"
"int tl_x2 = point2 % width;\n"
"int tl_y2 = point2 / width;\n"
"int cur_x = start_x + tl_x;\n"
"int cur_y = start_y + tl_y;\n"
"int cur_x2 = start_x + tl_x2;\n"
"int cur_y2 = start_y + tl_y2;\n"
"int start_addr = mad24(cur_y,src_step, cur_x*(int)sizeof(GENTYPE));\n"
"int start_addr2 = mad24(cur_y2,src_step, cur_x2*(int)sizeof(GENTYPE));\n"
"GENTYPE temp0,temp1;\n"
"__local GENTYPE LDS_DAT[2*LSIZE1*LSIZE0];\n"
"int end_addr = mad24(src_whole_rows - 1,src_step,src_whole_cols*(int)sizeof(GENTYPE));\n"
"start_addr = ((start_addr < end_addr) && (start_addr > 0)) ? start_addr : 0;\n"
"start_addr2 = ((start_addr2 < end_addr) && (start_addr2 > 0)) ? start_addr2 : 0;\n"
"__global const GENTYPE * src;\n"
"src = (__global const GENTYPE *)(srcptr+start_addr);\n"
"temp0 = src[0];\n"
"src = (__global const GENTYPE *)(srcptr+start_addr2);\n"
"temp1 = src[0];\n"
"temp0= ELEM(cur_x,0,src_whole_cols,(GENTYPE)VAL,temp0);\n"
"temp0= ELEM(cur_y,0,src_whole_rows,(GENTYPE)VAL,temp0);\n"
"temp1= ELEM(cur_x2,0,src_whole_cols,(GENTYPE)VAL,temp1);\n"
"temp1= ELEM(cur_y2,0,src_whole_rows,(GENTYPE)VAL,temp1);\n"
"LDS_DAT[point1] = temp0;\n"
"LDS_DAT[point2] = temp1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"GENTYPE res = (GENTYPE)VAL;\n"
"for(int i=0; i<2*RADIUSY+1; i++)\n"
"for(int j=0; j<2*RADIUSX+1; j++)\n"
"{\n"
"res =\n"
"#ifndef RECTKERNEL\n"
"mat_kernel[i*(2*RADIUSX+1)+j] ?\n"
"#endif\n"
"MORPH_OP(res,LDS_DAT[mad24(l_y+i,width,l_x+j)])\n"
"#ifndef RECTKERNEL\n"
":res\n"
"#endif\n"
";\n"
"}\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if(gidx<cols && gidy<rows)\n"
"{\n"
"int dst_index = mad24(gidy, dst_step, dst_offset + gidx * (int)sizeof(GENTYPE));\n"
"__global GENTYPE * dst = (__global GENTYPE *)(dstptr + dst_index);\n"
"dst[0] = res;\n"
"}\n"
"}\n"
, "01e051b9e10f792c9b6bddde7a5bb218"};
ProgramSource morph_oclsrc(morph.programStr);
const struct ProgramEntry precornerdetect={"precornerdetect",
"__kernel void preCornerDetect(__global const uchar * Dxptr, int dx_step, int dx_offset,\n"
"__global const uchar * Dyptr, int dy_step, int dy_offset,\n"
"__global const uchar * D2xptr, int d2x_step, int d2x_offset,\n"
"__global const uchar * D2yptr, int d2y_step, int d2y_offset,\n"
"__global const uchar * Dxyptr, int dxy_step, int dxy_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int dst_rows, int dst_cols, float factor)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dx_index = mad24(dx_step, y, (int)sizeof(float) * x + dx_offset);\n"
"int dy_index = mad24(dy_step, y, (int)sizeof(float) * x + dy_offset);\n"
"int d2x_index = mad24(d2x_step, y, (int)sizeof(float) * x + d2x_offset);\n"
"int d2y_index = mad24(d2y_step, y, (int)sizeof(float) * x + d2y_offset);\n"
"int dxy_index = mad24(dxy_step, y, (int)sizeof(float) * x + dxy_offset);\n"
"int dst_index = mad24(dst_step, y, (int)sizeof(float) * x + dst_offset);\n"
"float dx = *(__global const float *)(Dxptr + dx_index);\n"
"float dy = *(__global const float *)(Dyptr + dy_index);\n"
"float d2x = *(__global const float *)(D2xptr + d2x_index);\n"
"float d2y = *(__global const float *)(D2yptr + d2y_index);\n"
"float dxy = *(__global const float *)(Dxyptr + dxy_index);\n"
"__global float * dst = (__global float *)(dstptr + dst_index);\n"
"dst[0] = factor * (dx*dx*d2y + dy*dy*d2x - 2*dx*dy*dxy);\n"
"}\n"
"}\n"
, "14a94db70b88aa76ff8840f03f3ad556"};
ProgramSource precornerdetect_oclsrc(precornerdetect.programStr);
const struct ProgramEntry pyr_down={"pyr_down",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"inline int idx_row_low(int y, int last_row)\n"
"{\n"
"return abs(y) % (last_row + 1);\n"
"}\n"
"inline int idx_row_high(int y, int last_row)\n"
"{\n"
"return abs(last_row - (int)abs(last_row - y)) % (last_row + 1);\n"
"}\n"
"inline int idx_row(int y, int last_row)\n"
"{\n"
"return idx_row_low(idx_row_high(y, last_row), last_row);\n"
"}\n"
"inline int idx_col_low(int x, int last_col)\n"
"{\n"
"return abs(x) % (last_col + 1);\n"
"}\n"
"inline int idx_col_high(int x, int last_col)\n"
"{\n"
"return abs(last_col - (int)abs(last_col - x)) % (last_col + 1);\n"
"}\n"
"inline int idx_col(int x, int last_col)\n"
"{\n"
"return idx_col_low(idx_col_high(x, last_col), last_col);\n"
"}\n"
"__kernel void pyrDown(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local FT smem[256 + 4];\n"
"__global T * dstData = (__global T *)(dst + dst_offset);\n"
"__global const uchar * srcData = (__global const uchar*)(src + src_offset);\n"
"FT sum;\n"
"FT co1 = 0.375f;\n"
"FT co2 = 0.25f;\n"
"FT co3 = 0.0625f;\n"
"const int src_y = 2*y;\n"
"const int last_row = src_rows - 1;\n"
"const int last_col = src_cols - 1;\n"
"if (src_y >= 2 && src_y < src_rows - 2 && x >= 2 && x < src_cols - 2)\n"
"{\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + (src_y - 2) * src_step))[x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y - 1) * src_step))[x]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + (src_y    ) * src_step))[x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y + 1) * src_step))[x]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + (src_y + 2) * src_step))[x]);\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + (src_y - 2) * src_step))[left_x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y - 1) * src_step))[left_x]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + (src_y    ) * src_step))[left_x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y + 1) * src_step))[left_x]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + (src_y + 2) * src_step))[left_x]);\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + (src_y - 2) * src_step))[right_x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y - 1) * src_step))[right_x]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + (src_y    ) * src_step))[right_x]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + (src_y + 1) * src_step))[right_x]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + (src_y + 2) * src_step))[right_x]);\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + idx_row(src_y - 2, last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y - 1, last_row) * src_step))[col]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + idx_row(src_y    , last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y + 1, last_row) * src_step))[col]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + idx_row(src_y + 2, last_row) * src_step))[col]);\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + idx_row(src_y - 2, last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y - 1, last_row) * src_step))[col]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + idx_row(src_y    , last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y + 1, last_row) * src_step))[col]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + idx_row(src_y + 2, last_row) * src_step))[col]);\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       co3 * convertToFT(((__global T*)(srcData + idx_row(src_y - 2, last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y - 1, last_row) * src_step))[col]);\n"
"sum = sum + co1 * convertToFT(((__global T*)(srcData + idx_row(src_y    , last_row) * src_step))[col]);\n"
"sum = sum + co2 * convertToFT(((__global T*)(srcData + idx_row(src_y + 1, last_row) * src_step))[col]);\n"
"sum = sum + co3 * convertToFT(((__global T*)(srcData + idx_row(src_y + 2, last_row) * src_step))[col]);\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       co3 * smem[2 + tid2 - 2];\n"
"sum = sum + co2 * smem[2 + tid2 - 1];\n"
"sum = sum + co1 * smem[2 + tid2    ];\n"
"sum = sum + co2 * smem[2 + tid2 + 1];\n"
"sum = sum + co3 * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dst_cols)\n"
"dstData[y * dst_step / ((int)sizeof(T)) + dst_x] = convertToT(sum);\n"
"}\n"
"}\n"
, "d6cabcccda30b9ab1dc2257698e6a0c0"};
ProgramSource pyr_down_oclsrc(pyr_down.programStr);
const struct ProgramEntry pyr_up={"pyr_up",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"__kernel void pyrUp(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"__local FT s_srcPatch[10][10];\n"
"__local FT s_dstPatch[20][16];\n"
"__global T * dstData = (__global T *)(dst + dst_offset);\n"
"__global const T * srcData = (__global const T *)(src + src_offset);\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = mad24((int)get_group_id(0), lsizex>>1, tidx) - 1;\n"
"int srcy = mad24((int)get_group_id(1), lsizey>>1, tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(src_cols - 1, srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(src_rows - 1, srcy);\n"
"s_srcPatch[tidy][tidx] = convertToFT(srcData[srcx + srcy * src_step / (int) sizeof(T)]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"FT sum = 0.f;\n"
"const FT evenFlag = (FT)((tidx & 1) == 0);\n"
"const FT  oddFlag = (FT)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"const FT co1 = 0.375f;\n"
"const FT co2 = 0.25f;\n"
"const FT co3 = 0.0625f;\n"
"if(eveny)\n"
"{\n"
"sum =       ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + ( evenFlag* co1 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + tidy][tidx] = sum;\n"
"if (tidy < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum =       (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1 ) * s_srcPatch[lsizey-16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[tidy][tidx] = sum;\n"
"}\n"
"if (tidy > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum =       (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[lsizey-7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =       co3 * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + co1 * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + co3 * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dst_cols) && (y < dst_rows))\n"
"dstData[x + y * dst_step / (int)sizeof(T)] = convertToT(4.0f * sum);\n"
"}\n"
, "31dc3557c666325e9208ec4ff7a4568f"};
ProgramSource pyr_up_oclsrc(pyr_up.programStr);
const struct ProgramEntry remap={"remap",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"enum\n"
"{\n"
"INTER_BITS = 5,\n"
"INTER_TAB_SIZE = 1 << INTER_BITS,\n"
"INTER_TAB_SIZE2 = INTER_TAB_SIZE * INTER_TAB_SIZE\n"
"};\n"
"#ifdef INTER_NEAREST\n"
"#define convertToWT\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#define EXTRAPOLATE(v2, v) v = scalar;\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"v2 = max(min(v2, (int2)(src_cols - 1, src_rows - 1)), (int2)(0)); \\\n"
"v = convertToWT(*((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * (int)sizeof(T) + src_offset)))); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"if (v2.x < 0) \\\n"
"v2.x -= ((v2.x - src_cols + 1) / src_cols) * src_cols; \\\n"
"if (v2.x >= src_cols) \\\n"
"v2.x %= src_cols; \\\n"
"\\\n"
"if (v2.y < 0) \\\n"
"v2.y -= ((v2.y - src_rows + 1) / src_rows) * src_rows; \\\n"
"if( v2.y >= src_rows ) \\\n"
"v2.y %= src_rows; \\\n"
"v = convertToWT(*((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * (int)sizeof(T) + src_offset)))); \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#ifdef BORDER_REFLECT\n"
"#define DELTA int delta = 0\n"
"#else\n"
"#define DELTA int delta = 1\n"
"#endif\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"DELTA; \\\n"
"if (src_cols == 1) \\\n"
"v2.x = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if( v2.x < 0 ) \\\n"
"v2.x = -v2.x - 1 + delta; \\\n"
"else \\\n"
"v2.x = src_cols - 1 - (v2.x - src_cols) - delta; \\\n"
"} \\\n"
"while (v2.x >= src_cols || v2.x < 0); \\\n"
"\\\n"
"if (src_rows == 1) \\\n"
"v2.y = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if( v2.y < 0 ) \\\n"
"v2.y = -v2.y - 1 + delta; \\\n"
"else \\\n"
"v2.y = src_rows - 1 - (v2.y - src_rows) - delta; \\\n"
"} \\\n"
"while (v2.y >= src_rows || v2.y < 0); \\\n"
"v = convertToWT(*((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * (int)sizeof(T) + src_offset)))); \\\n"
"}\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define NEED_EXTRAPOLATION(gx, gy) (gx >= src_cols || gy >= src_rows || gx < 0 || gy < 0)\n"
"#ifdef INTER_NEAREST\n"
"__kernel void remap_2_32FC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"T scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(float) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(float) + map2_offset);\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"__global const float * map1 = (__global const float *)(map1ptr + map1_index);\n"
"__global const float * map2 = (__global const float *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int gx = convert_int_sat_rte(map1[0]);\n"
"int gy = convert_int_sat_rte(map2[0]);\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"{\n"
"#ifndef BORDER_CONSTANT\n"
"int2 gxy = (int2)(gx, gy);\n"
"#endif\n"
"EXTRAPOLATE(gxy, dst[0])\n"
"}\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * (int)sizeof(T) + src_offset);\n"
"dst[0] = *((__global const T*)(srcptr + src_index));\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_32FC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"T scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(float2) + map_offset);\n"
"__global const float2 * map = (__global const float2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 gxy = convert_int2_sat_rte(map[0]);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"EXTRAPOLATE(gxy, dst[0])\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * (int)sizeof(T) + src_offset);\n"
"dst[0] = *((__global const T *)(srcptr + src_index));\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_16SC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"T scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(short2) + map_offset);\n"
"__global const short2 * map = (__global const short2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 gxy = convert_int2(map[0]);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"EXTRAPOLATE(gxy, dst[0])\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * (int)sizeof(T) + src_offset);\n"
"dst[0] = *((__global const T *)(srcptr + src_index));\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_16SC2_16UC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"T scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(short2) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(ushort) + map2_offset);\n"
"__global const short2 * map1 = (__global const short2 *)(map1ptr + map1_index);\n"
"__global const ushort * map2 = (__global const ushort *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int map2Value = convert_int(map2[0]) & (INTER_TAB_SIZE2 - 1);\n"
"int dx = (map2Value & (INTER_TAB_SIZE - 1)) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\n"
"int dy = (map2Value >> INTER_BITS) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\n"
"int2 gxy = convert_int2(map1[0]) + (int2)(dx, dy);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"EXTRAPOLATE(gxy, dst[0])\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * (int)sizeof(T) + src_offset);\n"
"dst[0] = *((__global const T *)(srcptr + src_index));\n"
"}\n"
"}\n"
"}\n"
"#elif INTER_LINEAR\n"
"__kernel void remap_16SC2_16UC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"T nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(short2) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(ushort) + map2_offset);\n"
"__global const short2 * map1 = (__global const short2 *)(map1ptr + map1_index);\n"
"__global const ushort * map2 = (__global const ushort *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 map_dataA = convert_int2(map1[0]);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"ushort map2Value = (ushort)(map2[0] & (INTER_TAB_SIZE2 - 1));\n"
"WT2 u = (WT2)(map2Value & (INTER_TAB_SIZE - 1), map2Value >> INTER_BITS) / (WT2)(INTER_TAB_SIZE);\n"
"WT scalar = convertToWT(nVal);\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(*((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(*((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(*((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(*((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"dst[0] = convertToT(dst_data);\n"
"}\n"
"}\n"
"__kernel void remap_2_32FC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"T nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(float) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(float) + map2_offset);\n"
"__global const float * map1 = (__global const float *)(map1ptr + map1_index);\n"
"__global const float * map2 = (__global const float *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"float2 map_data = (float2)(map1[0], map2[0]);\n"
"int2 map_dataA = convert_int2_sat_rtn(map_data);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"float2 _u = map_data - convert_float2(map_dataA);\n"
"WT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\n"
"WT scalar = convertToWT(nVal);\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(*((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(*((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(*((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(*((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"dst[0] = convertToT(dst_data);\n"
"}\n"
"}\n"
"__kernel void remap_32FC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"T nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * (int)sizeof(T) + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(float2) + map_offset);\n"
"__global const float2 * map = (__global const float2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"float2 map_data = map[0];\n"
"int2 map_dataA = convert_int2_sat_rtn(map_data);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"float2 _u = map_data - convert_float2(map_dataA);\n"
"WT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\n"
"WT scalar = convertToWT(nVal);\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(*((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(*((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(*((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(*((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * (int)sizeof(T) + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"dst[0] = convertToT(dst_data);\n"
"}\n"
"}\n"
"#endif\n"
, "4e8adc0d3fa98425cf95775b6b5d2d1d"};
ProgramSource remap_oclsrc(remap.programStr);
const struct ProgramEntry resize={"resize",
"#if defined DOUBLE_SUPPORT\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define INTER_RESIZE_COEF_BITS 11\n"
"#define INTER_RESIZE_COEF_SCALE (1 << INTER_RESIZE_COEF_BITS)\n"
"#define CAST_BITS (INTER_RESIZE_COEF_BITS << 1)\n"
"#define INC(x,l) min(x+1,l-1)\n"
"#define PIXSIZE ((int)sizeof(PIXTYPE))\n"
"#define noconvert(x) (x)\n"
"#if defined INTER_LINEAR\n"
"__kernel void resizeLN(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"int srcrows, int srccols,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int dstrows, int dstcols,\n"
"float ifx, float ify)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\n"
"int x = floor(sx), y = floor(sy);\n"
"float u = sx - x, v = sy - y;\n"
"if ( x<0 ) x=0,u=0;\n"
"if ( x>=srccols ) x=srccols-1,u=0;\n"
"if ( y<0 ) y=0,v=0;\n"
"if ( y>=srcrows ) y=srcrows-1,v=0;\n"
"int y_ = INC(y,srcrows);\n"
"int x_ = INC(x,srccols);\n"
"#if depth <= 4\n"
"u = u * INTER_RESIZE_COEF_SCALE;\n"
"v = v * INTER_RESIZE_COEF_SCALE;\n"
"int U = rint(u);\n"
"int V = rint(v);\n"
"int U1 = rint(INTER_RESIZE_COEF_SCALE - u);\n"
"int V1 = rint(INTER_RESIZE_COEF_SCALE - v);\n"
"WORKTYPE data0 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y, srcstep, srcoffset + x*PIXSIZE)));\n"
"WORKTYPE data1 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y, srcstep, srcoffset + x_*PIXSIZE)));\n"
"WORKTYPE data2 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y_, srcstep, srcoffset + x*PIXSIZE)));\n"
"WORKTYPE data3 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y_, srcstep, srcoffset + x_*PIXSIZE)));\n"
"WORKTYPE val = mul24((WORKTYPE)mul24(U1, V1), data0) + mul24((WORKTYPE)mul24(U, V1), data1) +\n"
"mul24((WORKTYPE)mul24(U1, V), data2) + mul24((WORKTYPE)mul24(U, V), data3);\n"
"PIXTYPE uval = convertToDT((val + (1<<(CAST_BITS-1)))>>CAST_BITS);\n"
"#else\n"
"float u1 = 1.f - u;\n"
"float v1 = 1.f - v;\n"
"WORKTYPE data0 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y, srcstep, srcoffset + x*PIXSIZE)));\n"
"WORKTYPE data1 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y, srcstep, srcoffset + x_*PIXSIZE)));\n"
"WORKTYPE data2 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y_, srcstep, srcoffset + x*PIXSIZE)));\n"
"WORKTYPE data3 = convertToWT(*(__global const PIXTYPE*)(srcptr + mad24(y_, srcstep, srcoffset + x_*PIXSIZE)));\n"
"PIXTYPE uval = u1 * v1 * data0 + u * v1 * data1 + u1 * v *data2 + u * v *data3;\n"
"#endif\n"
"if(dx < dstcols && dy < dstrows)\n"
"{\n"
"__global PIXTYPE* dst = (__global PIXTYPE*)(dstptr + mad24(dy, dststep, dstoffset + dx*PIXSIZE));\n"
"dst[0] = uval;\n"
"}\n"
"}\n"
"#elif defined INTER_NEAREST\n"
"__kernel void resizeNN(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"int srcrows, int srccols,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int dstrows, int dstcols,\n"
"float ifx, float ify)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < dstcols && dy < dstrows )\n"
"{\n"
"float s1 = dx*ifx;\n"
"float s2 = dy*ify;\n"
"int sx = min(convert_int_rtz(s1), srccols-1);\n"
"int sy = min(convert_int_rtz(s2), srcrows-1);\n"
"__global PIXTYPE* dst = (__global PIXTYPE*)(dstptr + mad24(dy, dststep, dstoffset + dx*PIXSIZE));\n"
"__global const PIXTYPE* src = (__global const PIXTYPE*)(srcptr + mad24(sy, srcstep, srcoffset + sx*PIXSIZE));\n"
"dst[0] = src[0];\n"
"}\n"
"}\n"
"#elif defined INTER_AREA\n"
"#define TSIZE ((int)(sizeof(T)))\n"
"#ifdef INTER_AREA_FAST\n"
"__kernel void resizeAREA_FAST(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const int * dmap_tab, __global const int * smap_tab)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int dst_index = mad24(dy, dst_step, dst_offset);\n"
"__global const int * xmap_tab = dmap_tab;\n"
"__global const int * ymap_tab = dmap_tab + dst_cols;\n"
"__global const int * sxmap_tab = smap_tab;\n"
"__global const int * symap_tab = smap_tab + XSCALE * dst_cols;\n"
"int sx = xmap_tab[dx], sy = ymap_tab[dy];\n"
"WTV sum = (WTV)(0);\n"
"#pragma unroll\n"
"for (int y = 0; y < YSCALE; ++y)\n"
"{\n"
"int src_index = mad24(symap_tab[y + sy], src_step, src_offset);\n"
"#pragma unroll\n"
"for (int x = 0; x < XSCALE; ++x)\n"
"sum += convertToWTV(((__global const T*)(src + src_index))[sxmap_tab[sx + x]]);\n"
"}\n"
"((__global T*)(dst + dst_index))[dx] = convertToT(convertToWT2V(sum) * (WT2V)(SCALE));\n"
"}\n"
"}\n"
"#else\n"
"__kernel void resizeAREA(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"float ifx, float ify, __global const int * ofs_tab,\n"
"__global const int * map_tab, __global const float * alpha_tab)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int dst_index = mad24(dy, dst_step, dst_offset);\n"
"__global const int * xmap_tab = map_tab;\n"
"__global const int * ymap_tab = (__global const int *)(map_tab + (src_cols << 1));\n"
"__global const float * xalpha_tab = alpha_tab;\n"
"__global const float * yalpha_tab = (__global const float *)(alpha_tab + (src_cols << 1));\n"
"__global const int * xofs_tab = ofs_tab;\n"
"__global const int * yofs_tab = (__global const int *)(ofs_tab + dst_cols + 1);\n"
"int xk0 = xofs_tab[dx], xk1 = xofs_tab[dx + 1];\n"
"int yk0 = yofs_tab[dy], yk1 = yofs_tab[dy + 1];\n"
"int sy0 = ymap_tab[yk0], sy1 = ymap_tab[yk1 - 1];\n"
"int sx0 = xmap_tab[xk0], sx1 = xmap_tab[xk1 - 1];\n"
"WTV sum = (WTV)(0), buf;\n"
"int src_index = mad24(sy0, src_step, src_offset);\n"
"for (int sy = sy0, yk = yk0; sy <= sy1; ++sy, src_index += src_step, ++yk)\n"
"{\n"
"WTV beta = (WTV)(yalpha_tab[yk]);\n"
"buf = (WTV)(0);\n"
"for (int sx = sx0, xk = xk0; sx <= sx1; ++sx, ++xk)\n"
"{\n"
"WTV alpha = (WTV)(xalpha_tab[xk]);\n"
"buf += convertToWTV(((__global const T*)(src + src_index))[sx]) * alpha;\n"
"}\n"
"sum += buf * beta;\n"
"}\n"
"((__global T*)(dst + dst_index))[dx] = convertToT(sum);\n"
"}\n"
"}\n"
"#endif\n"
"#endif\n"
, "ebe98ca2451e6b3147d3d9e393959f17"};
ProgramSource resize_oclsrc(resize.programStr);
const struct ProgramEntry threshold={"threshold",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void threshold(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols,\n"
"T thresh, T max_val)\n"
"{\n"
"int gx = get_global_id(0);\n"
"int gy = get_global_id(1);\n"
"if (gx < cols && gy < rows)\n"
"{\n"
"int src_index = mad24(gy, src_step, src_offset + gx * (int)sizeof(T));\n"
"int dst_index = mad24(gy, dst_step, dst_offset + gx * (int)sizeof(T));\n"
"T sdata = *(__global const T *)(srcptr + src_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#ifdef THRESH_BINARY\n"
"dst[0] = sdata > thresh ? max_val : (T)(0);\n"
"#elif defined THRESH_BINARY_INV\n"
"dst[0] = sdata > thresh ? (T)(0) : max_val;\n"
"#elif defined THRESH_TRUNC\n"
"dst[0] = sdata > thresh ? thresh : sdata;\n"
"#elif defined THRESH_TOZERO\n"
"dst[0] = sdata > thresh ? sdata : (T)(0);\n"
"#elif defined THRESH_TOZERO_INV\n"
"dst[0] = sdata > thresh ? (T)(0) : sdata;\n"
"#endif\n"
"}\n"
"}\n"
, "f5175c0f7049237e5bb23212e26a79b8"};
ProgramSource threshold_oclsrc(threshold.programStr);
const struct ProgramEntry warp_affine={"warp_affine",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CT double\n"
"#else\n"
"#define CT float\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f/INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"#define noconvert\n"
"#ifdef INTER_NEAREST\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, T scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = (AB_SCALE >> 1);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"short sx = convert_short_sat(X0 >> AB_BITS);\n"
"short sy = convert_short_sat(Y0 >> AB_BITS);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * (int)sizeof(T));\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"if (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows)\n"
"{\n"
"int src_index = mad24(sy, src_step, src_offset + sx * (int)sizeof(T));\n"
"__global const T * src = (__global const T *)(srcptr + src_index);\n"
"dst[0] = src[0];\n"
"}\n"
"else\n"
"dst[0] = scalar;\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, WT scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx = convert_short_sat(X0 >> INTER_BITS);\n"
"short sy = convert_short_sat(Y0 >> INTER_BITS);\n"
"short ax = convert_short(X0 & (INTER_TAB_SIZE-1));\n"
"short ay = convert_short(Y0 & (INTER_TAB_SIZE-1));\n"
"WT v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy, src_step, src_offset + sx * (int)sizeof(T)))) : scalar;\n"
"WT v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy, src_step, src_offset + (sx+1) * (int)sizeof(T)))) : scalar;\n"
"WT v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+1, src_step, src_offset + sx * (int)sizeof(T)))) : scalar;\n"
"WT v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+1, src_step, src_offset + (sx+1) * (int)sizeof(T)))) : scalar;\n"
"float taby = 1.f/INTER_TAB_SIZE*ay;\n"
"float tabx = 1.f/INTER_TAB_SIZE*ax;\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * (int)sizeof(T));\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#if depth <= 4\n"
"int itab0 = convert_short_sat_rte( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab1 = convert_short_sat_rte( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE );\n"
"int itab2 = convert_short_sat_rte( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab3 = convert_short_sat_rte( taby*tabx * INTER_REMAP_COEF_SCALE );\n"
"WT val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"dst[0] = convertToT((val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS);\n"
"#else\n"
"float tabx2 = 1.0f - tabx, taby2 = 1.0f - taby;\n"
"WT val = v0 * tabx2 * taby2 +  v1 * tabx * taby2 + v2 * tabx2 * taby + v3 * tabx * taby;\n"
"dst[0] = convertToT(val);\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined INTER_CUBIC\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, WT scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = ((AB_SCALE>>INTER_BITS)>>1);\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"int sx = (short)(X0 >> INTER_BITS) - 1;\n"
"int sy = (short)(Y0 >> INTER_BITS) - 1;\n"
"int ay = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"int ax = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"WT v[16];\n"
"#pragma unroll\n"
"for (int y = 0; y < 4; y++)\n"
"#pragma unroll\n"
"for (int x = 0; x < 4; x++)\n"
"v[mad24(y, 4, x)] = (sx+x >= 0 && sx+x < src_cols && sy+y >= 0 && sy+y < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+y, src_step, src_offset + (sx+x) * (int)sizeof(T)))) : scalar;\n"
"float tab1y[4], tab1x[4];\n"
"float ayy = INTER_SCALE * ay;\n"
"float axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * (int)sizeof(T));\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"WT sum = (WT)(0);\n"
"#if depth <= 4\n"
"int itab[16];\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"itab[i] = rint(tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE);\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * itab[i];\n"
"dst[0] = convertToT( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS );\n"
"#else\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * tab1y[(i>>2)] * tab1x[(i&3)];\n"
"dst[0] = convertToT( sum );\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
, "91e59e88fc7970ddd25abf766344d433"};
ProgramSource warp_affine_oclsrc(warp_affine.programStr);
const struct ProgramEntry warp_perspective={"warp_perspective",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CT double\n"
"#else\n"
"#define CT float\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f / INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"#define noconvert\n"
"#ifdef INTER_NEAREST\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, T scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? 1.f / W : 0.0f;\n"
"short sx = convert_short_sat_rte(X0*W);\n"
"short sy = convert_short_sat_rte(Y0*W);\n"
"int dst_index = mad24(dy, dst_step, dx * (int)sizeof(T) + dst_offset);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"if (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows)\n"
"{\n"
"int src_index = mad24(sy, src_step, sx * (int)sizeof(T) + src_offset);\n"
"__global const T * src = (__global const T *)(srcptr + src_index);\n"
"dst[0] = src[0];\n"
"}\n"
"else\n"
"dst[0] = scalar;\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, WT scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? INTER_TAB_SIZE / W : 0.0f;\n"
"int X = rint(X0 * W), Y = rint(Y0 * W);\n"
"short sx = convert_short_sat(X >> INTER_BITS);\n"
"short sy = convert_short_sat(Y >> INTER_BITS);\n"
"short ay = (short)(Y & (INTER_TAB_SIZE - 1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE - 1));\n"
"WT v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy, src_step, src_offset + sx * (int)sizeof(T)))) : scalar;\n"
"WT v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy, src_step, src_offset + (sx+1) * (int)sizeof(T)))) : scalar;\n"
"WT v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+1, src_step, src_offset + sx * (int)sizeof(T)))) : scalar;\n"
"WT v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+1, src_step, src_offset + (sx+1) * (int)sizeof(T)))) : scalar;\n"
"float taby = 1.f/INTER_TAB_SIZE*ay;\n"
"float tabx = 1.f/INTER_TAB_SIZE*ax;\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * (int)sizeof(T));\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#if depth <= 4\n"
"int itab0 = convert_short_sat_rte( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab1 = convert_short_sat_rte( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE );\n"
"int itab2 = convert_short_sat_rte( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab3 = convert_short_sat_rte( taby*tabx * INTER_REMAP_COEF_SCALE );\n"
"WT val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"dst[0] = convertToT((val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS);\n"
"#else\n"
"float tabx2 = 1.0f - tabx, taby2 = 1.0f - taby;\n"
"WT val = v0 * tabx2 * taby2 +  v1 * tabx * taby2 + v2 * tabx2 * taby + v3 * tabx * taby;\n"
"dst[0] = convertToT(val);\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined INTER_CUBIC\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, WT scalar)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? INTER_TAB_SIZE / W : 0.0f;\n"
"int X = rint(X0 * W), Y = rint(Y0 * W);\n"
"short sx = convert_short_sat(X >> INTER_BITS) - 1;\n"
"short sy = convert_short_sat(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"WT v[16];\n"
"#pragma unroll\n"
"for (int y = 0; y < 4; y++)\n"
"#pragma unroll\n"
"for (int x = 0; x < 4; x++)\n"
"v[mad24(y, 4, x)] = (sx+x >= 0 && sx+x < src_cols && sy+y >= 0 && sy+y < src_rows) ?\n"
"convertToWT(*(__global const T *)(srcptr + mad24(sy+y, src_step, src_offset + (sx+x) * (int)sizeof(T)))) : scalar;\n"
"float tab1y[4], tab1x[4];\n"
"float ayy = INTER_SCALE * ay;\n"
"float axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * (int)sizeof(T));\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"WT sum = (WT)(0);\n"
"#if depth <= 4\n"
"int itab[16];\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"itab[i] = rint(tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE);\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * itab[i];\n"
"dst[0] = convertToT( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS );\n"
"#else\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * tab1y[(i>>2)] * tab1x[(i&3)];\n"
"dst[0] = convertToT( sum );\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
, "1e81920624e64392e8e4f5a3d54baea0"};
ProgramSource warp_perspective_oclsrc(warp_perspective.programStr);
}
}}
