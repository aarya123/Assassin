// This file is auto-generated. Do not edit!

#include "precomp.hpp"
#include "opencl_kernels.hpp"

namespace cv
{
namespace ocl
{
namespace video
{

const struct ProgramEntry bgfg_mog2={"bgfg_mog2",
"#if CN==1\n"
"#define T_MEAN float\n"
"#define F_ZERO (0.0f)\n"
"#define cnMode 1\n"
"#define frameToMean(a, b) (b) = *(a);\n"
"#define meanToFrame(a, b) *b = convert_uchar_sat(a);\n"
"inline float sqr(float val)\n"
"{\n"
"return val * val;\n"
"}\n"
"inline float sum(float val)\n"
"{\n"
"return val;\n"
"}\n"
"#else\n"
"#define T_MEAN float4\n"
"#define F_ZERO (0.0f, 0.0f, 0.0f, 0.0f)\n"
"#define cnMode 4\n"
"#define meanToFrame(a, b)\\\n"
"b[0] = convert_uchar_sat(a.x); \\\n"
"b[1] = convert_uchar_sat(a.y); \\\n"
"b[2] = convert_uchar_sat(a.z);\n"
"#define frameToMean(a, b)\\\n"
"b.x = a[0]; \\\n"
"b.y = a[1]; \\\n"
"b.z = a[2]; \\\n"
"b.w = 0.0f;\n"
"inline float sqr(const float4 val)\n"
"{\n"
"return val.x * val.x + val.y * val.y + val.z * val.z;\n"
"}\n"
"inline float sum(const float4 val)\n"
"{\n"
"return (val.x + val.y + val.z);\n"
"}\n"
"inline void swap4(__global float4* ptr, int x, int y, int k, int rows, int ptr_step)\n"
"{\n"
"float4 val = ptr[(k * rows + y) * ptr_step + x];\n"
"ptr[(k * rows + y) * ptr_step + x] = ptr[((k + 1) * rows + y) * ptr_step + x];\n"
"ptr[((k + 1) * rows + y) * ptr_step + x] = val;\n"
"}\n"
"#endif\n"
"inline void swap(__global float* ptr, int x, int y, int k, int rows, int ptr_step)\n"
"{\n"
"float val = ptr[(k * rows + y) * ptr_step + x];\n"
"ptr[(k * rows + y) * ptr_step + x] = ptr[((k + 1) * rows + y) * ptr_step + x];\n"
"ptr[((k + 1) * rows + y) * ptr_step + x] = val;\n"
"}\n"
"__kernel void mog2_kernel(__global const uchar* frame, int frame_step, int frame_offset, int frame_row, int frame_col,\n"
"__global uchar* modesUsed, int modesUsed_step, int modesUsed_offset,\n"
"__global uchar* weight, int weight_step, int weight_offset,\n"
"__global uchar* mean, int mean_step, int mean_offset,\n"
"__global uchar* variance, int var_step, int var_offset,\n"
"__global uchar* fgmask, int fgmask_step, int fgmask_offset,\n"
"float alphaT, float alpha1, float prune,\n"
"int detectShadows_flag,\n"
"float c_Tb, float c_TB, float c_Tg, float c_varMin,\n"
"float c_varMax, float c_varInit, float c_tau, uchar c_shadowVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"weight_step/= sizeof(float);\n"
"var_step   /= sizeof(float);\n"
"mean_step  /= (sizeof(float)*cnMode);\n"
"if( x < frame_col && y < frame_row)\n"
"{\n"
"__global const uchar* _frame = (frame + mad24( y, frame_step, x*CN + frame_offset));\n"
"T_MEAN pix;\n"
"frameToMean(_frame, pix);\n"
"bool background = false;\n"
"bool fitsPDF = false;\n"
"__global int* _modesUsed = (__global int*)(modesUsed + mad24( y, modesUsed_step, x*(int)(sizeof(int))));\n"
"int nmodes = _modesUsed[0];\n"
"int nNewModes = nmodes;\n"
"float totalWeight = 0.0f;\n"
"__global float* _weight = (__global float*)(weight);\n"
"__global float* _variance = (__global float*)(variance);\n"
"__global T_MEAN* _mean = (__global T_MEAN*)(mean);\n"
"for (int mode = 0; mode < nmodes; ++mode)\n"
"{\n"
"float c_weight = alpha1 * _weight[(mode * frame_row + y) * weight_step + x] + prune;\n"
"if (!fitsPDF)\n"
"{\n"
"float c_var = _variance[(mode * frame_row + y) * var_step + x];\n"
"T_MEAN c_mean = _mean[(mode * frame_row + y) * mean_step + x];\n"
"T_MEAN diff = c_mean - pix;\n"
"float dist2 = sqr(diff);\n"
"if (totalWeight < c_TB && dist2 < c_Tb * c_var)\n"
"background = true;\n"
"if (dist2 < c_Tg * c_var)\n"
"{\n"
"fitsPDF = true;\n"
"c_weight += alphaT;\n"
"float k = alphaT / c_weight;\n"
"_mean[(mode * frame_row + y) * mean_step + x] = c_mean - k * diff;\n"
"float varnew = c_var + k * (dist2 - c_var);\n"
"varnew = fmax(varnew, c_varMin);\n"
"varnew = fmin(varnew, c_varMax);\n"
"_variance[(mode * frame_row + y) * var_step + x] = varnew;\n"
"for (int i = mode; i > 0; --i)\n"
"{\n"
"if (c_weight < _weight[((i - 1) * frame_row + y) * weight_step + x])\n"
"break;\n"
"swap(_weight, x, y, i - 1, frame_row, weight_step);\n"
"swap(_variance, x, y, i - 1, frame_row, var_step);\n"
"#if (CN==1)\n"
"swap(_mean, x, y, i - 1, frame_row, mean_step);\n"
"#else\n"
"swap4(_mean, x, y, i - 1, frame_row, mean_step);\n"
"#endif\n"
"}\n"
"}\n"
"}\n"
"if (c_weight < -prune)\n"
"{\n"
"c_weight = 0.0f;\n"
"nmodes--;\n"
"}\n"
"_weight[(mode * frame_row + y) * weight_step + x] = c_weight;\n"
"totalWeight += c_weight;\n"
"}\n"
"totalWeight = 1.f / totalWeight;\n"
"for (int mode = 0; mode < nmodes; ++mode)\n"
"_weight[(mode * frame_row + y) * weight_step + x] *= totalWeight;\n"
"nmodes = nNewModes;\n"
"if (!fitsPDF)\n"
"{\n"
"int mode = nmodes == (NMIXTURES) ? (NMIXTURES) - 1 : nmodes++;\n"
"if (nmodes == 1)\n"
"_weight[(mode * frame_row + y) * weight_step + x] = 1.f;\n"
"else\n"
"{\n"
"_weight[(mode * frame_row + y) * weight_step + x] = alphaT;\n"
"for (int i = 0; i < nmodes - 1; ++i)\n"
"_weight[(i * frame_row + y) * weight_step + x] *= alpha1;\n"
"}\n"
"_mean[(mode * frame_row + y) * mean_step + x] = pix;\n"
"_variance[(mode * frame_row + y) * var_step + x] = c_varInit;\n"
"for (int i = nmodes - 1; i > 0; --i)\n"
"{\n"
"if (alphaT < _weight[((i - 1) * frame_row + y) * weight_step + x])\n"
"break;\n"
"swap(_weight, x, y, i - 1, frame_row, weight_step);\n"
"swap(_variance, x, y, i - 1, frame_row, var_step);\n"
"#if (CN==1)\n"
"swap(_mean, x, y, i - 1, frame_row, mean_step);\n"
"#else\n"
"swap4(_mean, x, y, i - 1, frame_row, mean_step);\n"
"#endif\n"
"}\n"
"}\n"
"_modesUsed[0] = nmodes;\n"
"bool isShadow = false;\n"
"if (detectShadows_flag && !background)\n"
"{\n"
"float tWeight = 0.0f;\n"
"for (int mode = 0; mode < nmodes; ++mode)\n"
"{\n"
"T_MEAN c_mean = _mean[(mode * frame_row + y) * mean_step + x];\n"
"T_MEAN pix_mean = pix * c_mean;\n"
"float numerator = sum(pix_mean);\n"
"float denominator = sqr(c_mean);\n"
"if (denominator == 0)\n"
"break;\n"
"if (numerator <= denominator && numerator >= c_tau * denominator)\n"
"{\n"
"float a = numerator / denominator;\n"
"T_MEAN dD = a * c_mean - pix;\n"
"if (sqr(dD) < c_Tb * _variance[(mode * frame_row + y) * var_step + x] * a * a)\n"
"{\n"
"isShadow = true;\n"
"break;\n"
"}\n"
"}\n"
"tWeight += _weight[(mode * frame_row + y) * weight_step + x];\n"
"if (tWeight > c_TB)\n"
"break;\n"
"}\n"
"}\n"
"__global int* _fgmask = (__global int*)(fgmask + mad24(y, fgmask_step, x*(int)(sizeof(int)) + fgmask_offset));\n"
"*_fgmask = background ? 0 : isShadow ? c_shadowVal : 255;\n"
"}\n"
"}\n"
"__kernel void getBackgroundImage2_kernel(__global const uchar* modesUsed, int modesUsed_step, int modesUsed_offset, int modesUsed_row, int modesUsed_col,\n"
"__global const uchar* weight, int weight_step, int weight_offset,\n"
"__global const uchar* mean, int mean_step, int mean_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"float c_TB)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < modesUsed_col && y < modesUsed_row)\n"
"{\n"
"__global int* _modesUsed = (__global int*)(modesUsed + mad24( y, modesUsed_step, x*(int)(sizeof(int))));\n"
"int nmodes = _modesUsed[0];\n"
"T_MEAN meanVal = (T_MEAN)F_ZERO;\n"
"float totalWeight = 0.0f;\n"
"for (int mode = 0; mode < nmodes; ++mode)\n"
"{\n"
"__global const float* _weight = (__global const float*)(weight + mad24(mode * modesUsed_row + y, weight_step, x*(int)(sizeof(float))));\n"
"float c_weight = _weight[0];\n"
"__global const T_MEAN* _mean = (__global const T_MEAN*)(mean + mad24(mode * modesUsed_row + y, mean_step, x*(int)(sizeof(float))*cnMode));\n"
"T_MEAN c_mean = _mean[0];\n"
"meanVal = meanVal + c_weight * c_mean;\n"
"totalWeight += c_weight;\n"
"if(totalWeight > c_TB)\n"
"break;\n"
"}\n"
"meanVal = meanVal * (1.f / totalWeight);\n"
"__global uchar* _dst = dst + y * dst_step + x*CN + dst_offset;\n"
"meanToFrame(meanVal, _dst);\n"
"}\n"
"}\n"
, "2a873a34dc6477d7db242ffa2d80cc66"};
ProgramSource bgfg_mog2_oclsrc(bgfg_mog2.programStr);
const struct ProgramEntry optical_flow_farneback={"optical_flow_farneback",
"#define tx  (int)get_local_id(0)\n"
"#define ty  get_local_id(1)\n"
"#define bx  get_group_id(0)\n"
"#define bdx (int)get_local_size(0)\n"
"#define BORDER_SIZE 5\n"
"#define MAX_KSIZE_HALF 100\n"
"#ifndef polyN\n"
"#define polyN 5\n"
"#endif\n"
"#if USE_DOUBLE\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define TYPE double\n"
"#define VECTYPE double4\n"
"#else\n"
"#define TYPE float\n"
"#define VECTYPE float4\n"
"#endif\n"
"__kernel void polynomialExpansion(__global __const float * src, int srcStep,\n"
"__global float * dst, int dstStep,\n"
"const int rows, const  int cols,\n"
"__global __const float * c_g,\n"
"__global __const float * c_xg,\n"
"__global __const float * c_xxg,\n"
"__local float * smem,\n"
"const VECTYPE ig)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = bx * (bdx - 2*polyN) + tx - polyN;\n"
"int xWarped;\n"
"__local float *row = smem + tx;\n"
"if (y < rows && y >= 0)\n"
"{\n"
"xWarped = min(max(x, 0), cols - 1);\n"
"row[0] = src[mad24(y, srcStep, xWarped)] * c_g[0];\n"
"row[bdx] = 0.f;\n"
"row[2*bdx] = 0.f;\n"
"#pragma unroll\n"
"for (int k = 1; k <= polyN; ++k)\n"
"{\n"
"float t0 = src[mad24(max(y - k, 0), srcStep, xWarped)];\n"
"float t1 = src[mad24(min(y + k, rows - 1), srcStep, xWarped)];\n"
"row[0] += c_g[k] * (t0 + t1);\n"
"row[bdx] += c_xg[k] * (t1 - t0);\n"
"row[2*bdx] += c_xxg[k] * (t0 + t1);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (y < rows && y >= 0 && tx >= polyN && tx + polyN < bdx && x < cols)\n"
"{\n"
"TYPE b1 = c_g[0] * row[0];\n"
"TYPE b3 = c_g[0] * row[bdx];\n"
"TYPE b5 = c_g[0] * row[2*bdx];\n"
"TYPE b2 = 0, b4 = 0, b6 = 0;\n"
"#pragma unroll\n"
"for (int k = 1; k <= polyN; ++k)\n"
"{\n"
"b1 += (row[k] + row[-k]) * c_g[k];\n"
"b4 += (row[k] + row[-k]) * c_xxg[k];\n"
"b2 += (row[k] - row[-k]) * c_xg[k];\n"
"b3 += (row[k + bdx] + row[-k + bdx]) * c_g[k];\n"
"b6 += (row[k + bdx] - row[-k + bdx]) * c_xg[k];\n"
"b5 += (row[k + 2*bdx] + row[-k + 2*bdx]) * c_g[k];\n"
"}\n"
"dst[mad24(y, dstStep, xWarped)] = (float)(b3*ig.s0);\n"
"dst[mad24(rows + y, dstStep, xWarped)] = (float)(b2*ig.s0);\n"
"dst[mad24(2*rows + y, dstStep, xWarped)] = (float)(b1*ig.s1 + b5*ig.s2);\n"
"dst[mad24(3*rows + y, dstStep, xWarped)] = (float)(b1*ig.s1 + b4*ig.s2);\n"
"dst[mad24(4*rows + y, dstStep, xWarped)] = (float)(b6*ig.s3);\n"
"}\n"
"}\n"
"inline int idx_row_low(const int y, const int last_row)\n"
"{\n"
"return abs(y) % (last_row + 1);\n"
"}\n"
"inline int idx_row_high(const int y, const int last_row)\n"
"{\n"
"return abs(last_row - abs(last_row - y)) % (last_row + 1);\n"
"}\n"
"inline int idx_col_low(const int x, const int last_col)\n"
"{\n"
"return abs(x) % (last_col + 1);\n"
"}\n"
"inline int idx_col_high(const int x, const int last_col)\n"
"{\n"
"return abs(last_col - abs(last_col - x)) % (last_col + 1);\n"
"}\n"
"inline int idx_col(const int x, const int last_col)\n"
"{\n"
"return idx_col_low(idx_col_high(x, last_col), last_col);\n"
"}\n"
"__kernel void gaussianBlur(__global const float * src, int srcStep,\n"
"__global float * dst, int dstStep, const int rows, const  int cols,\n"
"__global const float * c_gKer, const int ksizeHalf,\n"
"__local float * smem)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = get_global_id(0);\n"
"__local float *row = smem + ty * (bdx + 2*ksizeHalf);\n"
"if (y < rows)\n"
"{\n"
"for (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n"
"{\n"
"int xExt = (int)(bx * bdx) + i - ksizeHalf;\n"
"xExt = idx_col(xExt, cols - 1);\n"
"row[i] = src[mad24(y, srcStep, xExt)] * c_gKer[0];\n"
"for (int j = 1; j <= ksizeHalf; ++j)\n"
"row[i] += (src[mad24(idx_row_low(y - j, rows - 1), srcStep, xExt)]\n"
"+ src[mad24(idx_row_high(y + j, rows - 1), srcStep, xExt)]) * c_gKer[j];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (y < rows && y >= 0 && x < cols && x >= 0)\n"
"{\n"
"row += tx + ksizeHalf;\n"
"float res = row[0] * c_gKer[0];\n"
"for (int i = 1; i <= ksizeHalf; ++i)\n"
"res += (row[-i] + row[i]) * c_gKer[i];\n"
"dst[mad24(y, dstStep, x)] = res;\n"
"}\n"
"}\n"
"__kernel void gaussianBlur5(__global const float * src, int srcStep,\n"
"__global float * dst, int dstStep,\n"
"const int rows, const  int cols,\n"
"__global const float * c_gKer, const int ksizeHalf,\n"
"__local float * smem)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = get_global_id(0);\n"
"const int smw = bdx + 2*ksizeHalf;\n"
"__local volatile float *row = smem + 5 * ty * smw;\n"
"if (y < rows)\n"
"{\n"
"for (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n"
"{\n"
"int xExt = (int)(bx * bdx) + i - ksizeHalf;\n"
"xExt = idx_col(xExt, cols - 1);\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"row[k*smw + i] = src[mad24(k*rows + y, srcStep, xExt)] * c_gKer[0];\n"
"for (int j = 1; j <= ksizeHalf; ++j)\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"row[k*smw + i] +=\n"
"(src[mad24(k*rows + idx_row_low(y - j, rows - 1), srcStep, xExt)] +\n"
"src[mad24(k*rows + idx_row_high(y + j, rows - 1), srcStep, xExt)]) * c_gKer[j];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (y < rows && y >= 0 && x < cols && x >= 0)\n"
"{\n"
"row += tx + ksizeHalf;\n"
"float res[5];\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"res[k] = row[k*smw] * c_gKer[0];\n"
"for (int i = 1; i <= ksizeHalf; ++i)\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"res[k] += (row[k*smw - i] + row[k*smw + i]) * c_gKer[i];\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"dst[mad24(k*rows + y, dstStep, x)] = res[k];\n"
"}\n"
"}\n"
"__constant float c_border[BORDER_SIZE + 1] = { 0.14f, 0.14f, 0.4472f, 0.4472f, 0.4472f, 1.f };\n"
"__kernel void updateMatrices(__global const float * flowx, int xStep,\n"
"__global const float * flowy, int yStep,\n"
"const int rows, const int cols,\n"
"__global const float * R0, int R0Step,\n"
"__global const float * R1, int R1Step,\n"
"__global float * M, int mStep)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = get_global_id(0);\n"
"if (y < rows && y >= 0 && x < cols && x >= 0)\n"
"{\n"
"float dx = flowx[mad24(y, xStep, x)];\n"
"float dy = flowy[mad24(y, yStep, x)];\n"
"float fx = x + dx;\n"
"float fy = y + dy;\n"
"int x1 = convert_int(floor(fx));\n"
"int y1 = convert_int(floor(fy));\n"
"fx -= x1;\n"
"fy -= y1;\n"
"float r2, r3, r4, r5, r6;\n"
"if (x1 >= 0 && y1 >= 0 && x1 < cols - 1 && y1 < rows - 1)\n"
"{\n"
"float a00 = (1.f - fx) * (1.f - fy);\n"
"float a01 = fx * (1.f - fy);\n"
"float a10 = (1.f - fx) * fy;\n"
"float a11 = fx * fy;\n"
"r2 = a00 * R1[mad24(y1, R1Step, x1)] +\n"
"a01 * R1[mad24(y1, R1Step, x1 + 1)] +\n"
"a10 * R1[mad24(y1 + 1, R1Step, x1)] +\n"
"a11 * R1[mad24(y1 + 1, R1Step, x1 + 1)];\n"
"r3 = a00 * R1[mad24(rows + y1, R1Step, x1)] +\n"
"a01 * R1[mad24(rows + y1, R1Step, x1 + 1)] +\n"
"a10 * R1[mad24(rows + y1 + 1, R1Step, x1)] +\n"
"a11 * R1[mad24(rows + y1 + 1, R1Step, x1 + 1)];\n"
"r4 = a00 * R1[mad24(2*rows + y1, R1Step, x1)] +\n"
"a01 * R1[mad24(2*rows + y1, R1Step, x1 + 1)] +\n"
"a10 * R1[mad24(2*rows + y1 + 1, R1Step, x1)] +\n"
"a11 * R1[mad24(2*rows + y1 + 1, R1Step, x1 + 1)];\n"
"r5 = a00 * R1[mad24(3*rows + y1, R1Step, x1)] +\n"
"a01 * R1[mad24(3*rows + y1, R1Step, x1 + 1)] +\n"
"a10 * R1[mad24(3*rows + y1 + 1, R1Step, x1)] +\n"
"a11 * R1[mad24(3*rows + y1 + 1, R1Step, x1 + 1)];\n"
"r6 = a00 * R1[mad24(4*rows + y1, R1Step, x1)] +\n"
"a01 * R1[mad24(4*rows + y1, R1Step, x1 + 1)] +\n"
"a10 * R1[mad24(4*rows + y1 + 1, R1Step, x1)] +\n"
"a11 * R1[mad24(4*rows + y1 + 1, R1Step, x1 + 1)];\n"
"r4 = (R0[mad24(2*rows + y, R0Step, x)] + r4) * 0.5f;\n"
"r5 = (R0[mad24(3*rows + y, R0Step, x)] + r5) * 0.5f;\n"
"r6 = (R0[mad24(4*rows + y, R0Step, x)] + r6) * 0.25f;\n"
"}\n"
"else\n"
"{\n"
"r2 = r3 = 0.f;\n"
"r4 = R0[mad24(2*rows + y, R0Step, x)];\n"
"r5 = R0[mad24(3*rows + y, R0Step, x)];\n"
"r6 = R0[mad24(4*rows + y, R0Step, x)] * 0.5f;\n"
"}\n"
"r2 = (R0[mad24(y, R0Step, x)] - r2) * 0.5f;\n"
"r3 = (R0[mad24(rows + y, R0Step, x)] - r3) * 0.5f;\n"
"r2 += r4*dy + r6*dx;\n"
"r3 += r6*dy + r5*dx;\n"
"float scale =\n"
"c_border[min(x, BORDER_SIZE)] *\n"
"c_border[min(y, BORDER_SIZE)] *\n"
"c_border[min(cols - x - 1, BORDER_SIZE)] *\n"
"c_border[min(rows - y - 1, BORDER_SIZE)];\n"
"r2 *= scale;\n"
"r3 *= scale;\n"
"r4 *= scale;\n"
"r5 *= scale;\n"
"r6 *= scale;\n"
"M[mad24(y, mStep, x)] = r4*r4 + r6*r6;\n"
"M[mad24(rows + y, mStep, x)] = (r4 + r5)*r6;\n"
"M[mad24(2*rows + y, mStep, x)] = r5*r5 + r6*r6;\n"
"M[mad24(3*rows + y, mStep, x)] = r4*r2 + r6*r3;\n"
"M[mad24(4*rows + y, mStep, x)] = r6*r2 + r5*r3;\n"
"}\n"
"}\n"
"__kernel void boxFilter5(__global const float * src, int srcStep,\n"
"__global float * dst, int dstStep,\n"
"const int rows, const  int cols,\n"
"const int ksizeHalf,\n"
"__local float * smem)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = get_global_id(0);\n"
"const float boxAreaInv = 1.f / ((1 + 2*ksizeHalf) * (1 + 2*ksizeHalf));\n"
"const int smw = bdx + 2*ksizeHalf;\n"
"__local float *row = smem + 5 * ty * smw;\n"
"if (y < rows)\n"
"{\n"
"for (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n"
"{\n"
"int xExt = (int)(bx * bdx) + i - ksizeHalf;\n"
"xExt = min(max(xExt, 0), cols - 1);\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"row[k*smw + i] = src[mad24(k*rows + y, srcStep, xExt)];\n"
"for (int j = 1; j <= ksizeHalf; ++j)\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"row[k*smw + i] +=\n"
"src[mad24(k*rows + max(y - j, 0), srcStep, xExt)] +\n"
"src[mad24(k*rows + min(y + j, rows - 1), srcStep, xExt)];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (y < rows && y >= 0 && x < cols && x >= 0)\n"
"{\n"
"row += tx + ksizeHalf;\n"
"float res[5];\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"res[k] = row[k*smw];\n"
"for (int i = 1; i <= ksizeHalf; ++i)\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"res[k] += row[k*smw - i] + row[k*smw + i];\n"
"#pragma unroll\n"
"for (int k = 0; k < 5; ++k)\n"
"dst[mad24(k*rows + y, dstStep, x)] = res[k] * boxAreaInv;\n"
"}\n"
"}\n"
"__kernel void updateFlow(__global const float * M, int mStep,\n"
"__global float * flowx, int xStep,\n"
"__global float * flowy, int yStep,\n"
"const int rows, const int cols)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = get_global_id(0);\n"
"if (y < rows && y >= 0 && x < cols && x >= 0)\n"
"{\n"
"float g11 = M[mad24(y, mStep, x)];\n"
"float g12 = M[mad24(rows + y, mStep, x)];\n"
"float g22 = M[mad24(2*rows + y, mStep, x)];\n"
"float h1 =  M[mad24(3*rows + y, mStep, x)];\n"
"float h2 =  M[mad24(4*rows + y, mStep, x)];\n"
"float detInv = 1.f / (g11*g22 - g12*g12 + 1e-3f);\n"
"flowx[mad24(y, xStep, x)] = (g11*h2 - g12*h1) * detInv;\n"
"flowy[mad24(y, yStep, x)] = (g22*h1 - g12*h2) * detInv;\n"
"}\n"
"}\n"
, "529300e6242f574f83d11a089cc120c0"};
ProgramSource optical_flow_farneback_oclsrc(optical_flow_farneback.programStr);
const struct ProgramEntry pyrlk={"pyrlk",
"#define  BUFFER  64\n"
"#define  BUFFER2  BUFFER>>1\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"#ifdef CPU\n"
"inline void reduce3(float val1, float val2, float val3,  __local float* smem1,  __local float* smem2,  __local float* smem3, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"smem3[tid] = val3;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int i = BUFFER2; i > 0; i >>= 1)\n"
"{\n"
"if(tid < i)\n"
"{\n"
"smem1[tid] += smem1[tid + i];\n"
"smem2[tid] += smem2[tid + i];\n"
"smem3[tid] += smem3[tid + i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"inline void reduce2(float val1, float val2, volatile __local float* smem1, volatile __local float* smem2, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int i = BUFFER2; i > 0; i >>= 1)\n"
"{\n"
"if(tid < i)\n"
"{\n"
"smem1[tid] += smem1[tid + i];\n"
"smem2[tid] += smem2[tid + i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"inline void reduce1(float val1, volatile __local float* smem1, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int i = BUFFER2; i > 0; i >>= 1)\n"
"{\n"
"if(tid < i)\n"
"{\n"
"smem1[tid] += smem1[tid + i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#else\n"
"inline void reduce3(float val1, float val2, float val3,\n"
"__local volatile float* smem1, __local volatile float* smem2, __local volatile float* smem3, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"smem3[tid] = val3;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] += smem1[tid + 32];\n"
"smem2[tid] += smem2[tid + 32];\n"
"smem3[tid] += smem3[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 16];\n"
"smem2[tid] += smem2[tid + 16];\n"
"smem3[tid] += smem3[tid + 16];\n"
"#if WAVE_SIZE <16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 8];\n"
"smem2[tid] += smem2[tid + 8];\n"
"smem3[tid] += smem3[tid + 8];\n"
"smem1[tid] += smem1[tid + 4];\n"
"smem2[tid] += smem2[tid + 4];\n"
"smem3[tid] += smem3[tid + 4];\n"
"smem1[tid] += smem1[tid + 2];\n"
"smem2[tid] += smem2[tid + 2];\n"
"smem3[tid] += smem3[tid + 2];\n"
"smem1[tid] += smem1[tid + 1];\n"
"smem2[tid] += smem2[tid + 1];\n"
"smem3[tid] += smem3[tid + 1];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"inline void reduce2(float val1, float val2, __local volatile float* smem1, __local volatile float* smem2, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] += smem1[tid + 32];\n"
"smem2[tid] += smem2[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 16];\n"
"smem2[tid] += smem2[tid + 16];\n"
"#if WAVE_SIZE <16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 8];\n"
"smem2[tid] += smem2[tid + 8];\n"
"smem1[tid] += smem1[tid + 4];\n"
"smem2[tid] += smem2[tid + 4];\n"
"smem1[tid] += smem1[tid + 2];\n"
"smem2[tid] += smem2[tid + 2];\n"
"smem1[tid] += smem1[tid + 1];\n"
"smem2[tid] += smem2[tid + 1];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"inline void reduce1(float val1, __local volatile float* smem1, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] += smem1[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 16];\n"
"#if WAVE_SIZE <16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem1[tid] += smem1[tid + 8];\n"
"smem1[tid] += smem1[tid + 4];\n"
"smem1[tid] += smem1[tid + 2];\n"
"smem1[tid] += smem1[tid + 1];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"#endif\n"
"#define SCALE (1.0f / (1 << 20))\n"
"#define  THRESHOLD  0.01f\n"
"__constant sampler_t sampler    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n"
"inline void SetPatch(image2d_t I, float x, float y,\n"
"float* Pch, float* Dx, float* Dy,\n"
"float* A11, float* A12, float* A22)\n"
"{\n"
"*Pch = read_imagef(I, sampler, (float2)(x, y)).x;\n"
"float dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x);\n"
"float dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x);\n"
"*Dx = dIdx;\n"
"*Dy = dIdy;\n"
"*A11 += dIdx * dIdx;\n"
"*A12 += dIdx * dIdy;\n"
"*A22 += dIdy * dIdy;\n"
"}\n"
"inline void GetPatch(image2d_t J, float x, float y,\n"
"float* Pch, float* Dx, float* Dy,\n"
"float* b1, float* b2)\n"
"{\n"
"float J_val = read_imagef(J, sampler, (float2)(x, y)).x;\n"
"float diff = (J_val - *Pch) * 32.0f;\n"
"*b1 += diff**Dx;\n"
"*b2 += diff**Dy;\n"
"}\n"
"inline void GetError(image2d_t J, const float x, const float y, const float* Pch, float* errval)\n"
"{\n"
"float diff = read_imagef(J, sampler, (float2)(x,y)).x-*Pch;\n"
"*errval += fabs(diff);\n"
"}\n"
"inline void SetPatch4(image2d_t I, const float x, const float y,\n"
"float4* Pch, float4* Dx, float4* Dy,\n"
"float* A11, float* A12, float* A22)\n"
"{\n"
"*Pch = read_imagef(I, sampler, (float2)(x, y));\n"
"float4 dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)));\n"
"float4 dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)));\n"
"*Dx = dIdx;\n"
"*Dy = dIdy;\n"
"float4 sqIdx = dIdx * dIdx;\n"
"*A11 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"sqIdx = dIdx * dIdy;\n"
"*A12 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"sqIdx = dIdy * dIdy;\n"
"*A22 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"}\n"
"inline void GetPatch4(image2d_t J, const float x, const float y,\n"
"const float4* Pch, const float4* Dx, const float4* Dy,\n"
"float* b1, float* b2)\n"
"{\n"
"float4 J_val = read_imagef(J, sampler, (float2)(x, y));\n"
"float4 diff = (J_val - *Pch) * 32.0f;\n"
"float4 xdiff = diff* *Dx;\n"
"*b1 += xdiff.x + xdiff.y + xdiff.z;\n"
"xdiff = diff* *Dy;\n"
"*b2 += xdiff.x + xdiff.y + xdiff.z;\n"
"}\n"
"inline void GetError4(image2d_t J, const float x, const float y, const float4* Pch, float* errval)\n"
"{\n"
"float4 diff = read_imagef(J, sampler, (float2)(x,y))-*Pch;\n"
"*errval += fabs(diff.x) + fabs(diff.y) + fabs(diff.z);\n"
"}\n"
"#define  GRIDSIZE  3\n"
"__kernel void lkSparse(image2d_t I, image2d_t J,\n"
"__global const float2* prevPts, int prevPtsStep, __global float2* nextPts, int nextPtsStep, __global uchar* status, __global float* err,\n"
"const int level, const int rows, const int cols, int PATCH_X, int PATCH_Y, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"__local float smem1[BUFFER];\n"
"__local float smem2[BUFFER];\n"
"__local float smem3[BUFFER];\n"
"unsigned int xid=get_local_id(0);\n"
"unsigned int yid=get_local_id(1);\n"
"unsigned int gid=get_group_id(0);\n"
"unsigned int xsize=get_local_size(0);\n"
"unsigned int ysize=get_local_size(1);\n"
"int xBase, yBase, k;\n"
"float2 c_halfWin = (float2)((c_winSize_x - 1)>>1, (c_winSize_y - 1)>>1);\n"
"const int tid = mad24(yid, xsize, xid);\n"
"float2 prevPt = prevPts[gid] / (float2)(1 << level);\n"
"if (prevPt.x < 0 || prevPt.x >= cols || prevPt.y < 0 || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[gid] = 0;\n"
"}\n"
"return;\n"
"}\n"
"prevPt -= c_halfWin;\n"
"float A11 = 0;\n"
"float A12 = 0;\n"
"float A22 = 0;\n"
"float I_patch[GRIDSIZE][GRIDSIZE];\n"
"float dIdx_patch[GRIDSIZE][GRIDSIZE];\n"
"float dIdy_patch[GRIDSIZE][GRIDSIZE];\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"reduce3(A11, A12, A22, smem1, smem2, smem3, tid);\n"
"A11 = smem1[0];\n"
"A12 = smem2[0];\n"
"A22 = smem3[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"A11 /= D;\n"
"A12 /= D;\n"
"A22 /= D;\n"
"prevPt = nextPts[gid] * 2.0f - c_halfWin;\n"
"for (k = 0; k < c_iters; ++k)\n"
"{\n"
"if (prevPt.x < -c_halfWin.x || prevPt.x >= cols || prevPt.y < -c_halfWin.y || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"float b1 = 0;\n"
"float b2 = 0;\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n"
"&b1, &b2);\n"
"}\n"
"reduce2(b1, b2, smem1, smem2, tid);\n"
"b1 = smem1[0];\n"
"b2 = smem2[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"prevPt += delta;\n"
"if (fabs(delta.x) < THRESHOLD && fabs(delta.y) < THRESHOLD)\n"
"break;\n"
"}\n"
"D = 0.0f;\n"
"if (calcErr)\n"
"{\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &D);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &D);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &D);\n"
"}\n"
"reduce1(D, smem1, tid);\n"
"}\n"
"if (tid == 0)\n"
"{\n"
"prevPt += c_halfWin;\n"
"nextPts[gid] = prevPt;\n"
"if (calcErr)\n"
"err[gid] = smem1[0] / (float)(c_winSize_x * c_winSize_y);\n"
"}\n"
"}\n"
, "e5ad6952ea08f2bcd00887334cbabeab"};
ProgramSource pyrlk_oclsrc(pyrlk.programStr);
const struct ProgramEntry updatemotionhistory={"updatemotionhistory",
"__kernel void updateMotionHistory(__global const uchar * silh, int silh_step, int silh_offset,\n"
"__global uchar * mhiptr, int mhi_step, int mhi_offset, int mhi_rows, int mhi_cols,\n"
"float timestamp, float delbound)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < mhi_cols && y < mhi_rows)\n"
"{\n"
"int silh_index = mad24(y, silh_step, silh_offset + x);\n"
"int mhi_index = mad24(y, mhi_step, mhi_offset + x * (int)sizeof(float));\n"
"silh += silh_index;\n"
"__global float * mhi = (__global float *)(mhiptr + mhi_index);\n"
"float val = mhi[0];\n"
"val = silh[0] ? timestamp : val < delbound ? 0 : val;\n"
"mhi[0] = val;\n"
"}\n"
"}\n"
, "b19beb01d0c6052524049341b55a2be5"};
ProgramSource updatemotionhistory_oclsrc(updatemotionhistory.programStr);
}
}}
